# Java基础

## 1、什么是 Java 内部类？ 内部类的分类有哪些 ？内部类有哪些优点和应用场景？

内部类是指定义在另⼀个类内部的类，它可以访问外部类的成员变量和⽅法。

内部类的分类有以下⼏种： 

- 成员内部类：定义在类内部，但在⽅法外部的类。它可以访问外部类的所有成员变量和⽅法； 

- 静态内部类：定义在类内部，但使⽤ static 修饰的类。它只能访问外部类的静态成员变量和⽅法； 

- 局部内部类：定义在⽅法内部的类。它只能访问⽅法内部的**final 变量和⽅法参数**； 

- 匿名内部类：没有类名的内部类，通常⽤于创建只需要使⽤⼀次的类。

内部类的合理使⽤存在以下优点： 

- 通过内部类变相地实现多继承，使得⼀个类可以**假性继承**多个⽗类； 

- 内部类可以隐藏实现细节，从⽽简化代码的编写； 

- 内部类可以访问外部类的私有成员变量和⽅法，从⽽增加了程序的灵活性和安全性。

内部类常⻅的使⽤场景如下： 

- 可⽤于实现**回调函数**提供给外部类使⽤； 

- 通过内部类中定义静态成员变量，利⽤内部类的加载机制，从⽽实现**单例模式**； 

- 有多继承需求时可使⽤内部类实现**假性多继承**。

  ###单例模式：

  **单例模式是指在内存中只会创建且仅创建一次对象的设计模式。**在程序中**多次使用同一个对象且作用相同**时，为了防止频繁地创建对象使得内存飙升，单例模式可以让程序仅在内存中**创建一个对象**，让所有需要调用的地方都共享这一单例对象。

  - 懒汉式：在**真正需要使用**对象时才去创建该单例类对象

    ~~~java
    public class SingletonDemo2 {
        //私有化构造器
        private SingletonDemo2() {
    
        }
    
        //只提供一个实例，并不创建对象
        private static SingletonDemo2 instance;
    
        //提供公共的获取方法,因为不是在类加载时就创建对象，因此存在线程安全问题，使用synchronized关键字保证线程安全，效率降低
        public static synchronized SingletonDemo2 getInstance() {
            if (instance == null) {
                instance = new SingletonDemo2();
            }
            return instance;
        }
    }
    ~~~

    

  - 饿汉式：在**类加载**时已经创建好该单例对象，等待被程序使用

    ~~~Java
    public class Singleton{
        private static final Singleton singleton = new Singleton();    
        private Singleton(){}    
        public static Singleton getInstance() {
            return singleton;
        }
    }
    ~~~

    

  - DCL懒汉式（双重检测锁模式）
  
    ~~~java
    public class Singleton {    
        private volatile static Singleton singleton; 
        private Singleton(){}
        public static Singleton getInstance() {
            if (singleton == null) {  // 线程A和线程B同时看到singleton = null，如果不为null，则直接返回singleton
                synchronized(Singleton.class) { // 线程A或线程B获得该锁进行初始化
                    if (singleton == null) { // 其中一个线程进入该分支，另外一个线程则不会进入该分支
                        singleton = new Singleton();
                    }
                }
            }
            return singleton;
        }   
    }
    ~~~

    

  - 静态内部类单例
  
    ~~~Java
    //静态内部类实现
    public class SingletonDemo4 {
        private SingletonDemo4() {
    
        }
        //不会在外部类初始化时就直接加载，只有当调用了getInstance方法时才会静态加载，线程安全，final保证了在内存中只有一份
        private static class InnerClass{
            private static final SingletonDemo4 instance = new SingletonDemo4();
        }
        public static SingletonDemo4 getInstance() {
            return InnerClass.instance;
        }
    }
    ~~~

  - 枚举单例（防止反射，序列化）
  
    ~~~Java
    //枚举方式实现单例模式
    public enum SingletonDemo5 {
        INSTANCE;
    
        public static SingletonDemo5 getInstance() {
            return INSTANCE;
        }
    }
    ~~~
  

线程池：**可以使⽤单例模式来确保系统中只有⼀个线程池。**

## 2、什么是反射机制？说说反射机制的优缺点、应⽤场景？

反射就是 Reflection，Java 的反射是指程序在运⾏期可以拿到⼀个对象的所有信息。 正常情况下，如果我们要调⽤⼀个对象的⽅法，或者访问⼀个对象的字段，通常会传⼊对象实例

优点: 

➢可以实现动态创建对象和编译，体现出很⼤的灵活性 

缺点: 

➢对性能有影响.使⽤反射基本上是-种解释操作，我们可以告诉JVM，我们希望做什么并且它满⾜我们的要求。这类 操作总是慢于直接执⾏相同的操作。

应用场景：

➢在运⾏时判断任意⼀个对象所属的类 

➢在运⾏时构造任意⼀个类的对象 

➢在运⾏时判断任意⼀个类所具有的成员变量和⽅法 

➢在运⾏时获取泛型信息 

➢在运⾏时调⽤任意⼀个对象的成员变量和⽅法 

➢在运⾏时处理注解 

➢⽣成动态代理（动态代理，因为不确定需要代理的类，所以需要通过反射动态的获取）

➢**RPC 框架**，RPC 框架就是动态的⽣成类对象，然后调⽤⽅法的。

## 3、说说 Java 中多态实现原理

多态机制包括静态多态（编译时多态）和动态多态（运行时多态） 

 静态多态比如说重载，动态多态一般指在运行时才能确定调用哪个方法。 

 我们通常所说✁多态一般指运行时多态，也就✁编译时不确定究竟调用哪个具体方法，一直等到运行时才能确定。 

 多态实现方式：子类继承父类（extends）和类实现➓口（implements）  多态核心之处就在于对父类方法✁改写或对➓口方法✁实现，以取得在运行时不同 ✁执行效果。  Java 里对象方法✁调用✁依靠类信息里✁方法表实现✁，对象方法引用调用和➓ 口方法引用调用✁大致思想✁一样✁。当调用对象✁某个方法时，JVM 查找该对象 类✁方法表以确定该方法✁直➓引用地址，有了地址后才真正调用该方法。

## 4、Java 中 IO 流分为几种?

- Java 中✁流分为两种：一种✁字节流，另一种✁字符流。 

- IO 流分别由四个抽象类来表示（两输入两输出）:InputStream，OutputStream，Reader，Writer

## 5、守护线程是什么？用什么方法实现守护线程

Java**线程分为用户线程和守护线程**。

守护线程是程序运行的时候在后台提供一种通用服务的线程。所有用户线程停止，进程会停掉所有守护线程，退出程序。

Java中把线程设置为守护线程的方法：在 start 线程之前调用线程的**setDaemon(true)** 方法。

注意：

- setDaemon(true) 必须在 start() 之前设置，否则会抛出IllegalThreadStateException异常，该线程仍默认为用户线程，继续执行
- 守护线程所创建的线程也是守护线程
- 守护线程**不应该访问、写入持久化资源，如文件、数据库，因为它会在任何时间被停止，导致资源未释放**、数据写入中断等问题。

## 6、Threadlocal

ThreadLocal叫做***线程变量***，意思是ThreadLocal中**填充的变量**属于**当前线程**，该变量对其他线程而言是隔离的，也就是说该变量是当前线程独有的变量。ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。

ThreadLoal 变量，线程局部变量，同一个 ThreadLocal 所包含的对象，在不同的 Thread 中有不同的副本。这里有几点需要注意：

- 因为每个 Thread 内有自己的实例副本，**且该副本只能由当前 Thread** 使用。
- 既然每个 Thread 有自己的实例副本，且其它 Thread 不可访问，那就**不存在多线程间共享**的问题。

ThreadLocal 提供了线程本地的实例。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。ThreadLocal 变量通常被private static修饰。**当一个线程结束时，它所使用的所有 ThreadLocal 相对的实例副本都可被回收**。

![](Redis.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA0NDUzMDE=,size_16,color_FFFFFF,t_70.png)

```java
private static ThreadLocal<String> localVarA = new ThreadLocal<String>();
private static ThreadLocal<String> localVarB = new ThreadLocal<String>();
```

ThreadLocalMap其实是Thread线程的一个属性值，而ThreadLocal是维护ThreadLocalMap这个属性指的一个工具类。*Thread线程可以拥有多个ThreadLocal维护的自己线程独享的共享变量*（这个共享变量只是针对自己线程里面共享）。

ThreadLocal 适用于如下两种场景：

- 1、**每个线程需要有自己单独的实例**
- 2、**实例需要在多个方法中共享，但不希望被多线程共享**

举例：

1）存储用户Session

2）数据库连接，处理数据库事务

​        注意pool.getConnection()，都是先从[threadlocal](https://so.csdn.net/so/search?q=threadlocal&spm=1001.2101.3001.7020)里面拿的，如果threadlocal里面有，则用，保证线程里的多个dao操作，用的是同一个connection，以保证事务。

​       如果新线程，则将新的connection放在threadlocal里，再get给到线程。

3）数据跨层传递（controller,service, dao）

4）**Spring使用ThreadLocal解决线程安全问题 **（Bean的作用域）

------

![image-20240520164954890](Redis.assets/image-20240520164954890.png)



## 7、ThreadLocal与Synchronized的区别

ThreadLocal<T>其实是与线程绑定的一个变量。**ThreadLocal和Synchonized都用于解决多线程并发访问。**

但是ThreadLocal与synchronized有本质的区别：

1、**Synchronized用于线程间的数据共享，而ThreadLocal则用于线程间的数据隔离。**

2、**Synchronized是利用锁的机制，使变量或代码块在某一时刻只能被一个线程访问。而ThreadLocal为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的数据共享。**

而Synchronized却正好相反，它**用于在多个线程间通信时能够获得数据共享**。

**一句话理解ThreadLocal，threadlocal是作为当前线程中属性ThreadLocalMap集合中的某一个Entry的key值Entry（threadlocal,value），虽然不同的线程之间threadlocal这个key值是一样，但是不同的线程所拥有的ThreadLocalMap是独一无二的，也就是不同的线程间同一个ThreadLocal（key）对应存储的值(value)不一样，从而到达了线程间变量隔离的目的，但是在同一个线程中这个value变量地址是一样的。**

## 8、<font color=red>线程池</font>

线程池是一种利用池化技术思想来实现的线程管理技术，主要是为了**复用线程、便利地管理线程和任务、并将线程的创建和任务的执行**解耦开来。我们可以创建线程池来复用**已经创建的线程来降低频繁创建和销毁线程所带来的资源消耗**。在JAVA中主要是使用**ThreadPoolExecutor类来创建线程池**，并且JDK中也提供了Executors工厂类来创建线程池（不推荐使用）。

<font color=red>**线程池的优点：**</font>

- **降低资源消耗**，复用已创建的线程来降低创建和销毁线程的消耗。
- **提高响应速度**，任务到达时，可以不需要等待线程的创建立即执行。
- **提高线程的可管理性**，使用线程池能够统一的分配、调优和监控。

**ThreadPoolExecutor的构造组成**

- **corePoolSize**，核心线程数量，决定是否创建新的线程来处理到来的任务
- **maximumPoolSize**，最大线程数量，线程池中允许创建线程地最大数量=（corePoolsize+救急线程）
- **keepAliveTime**，线程空闲时存活的时间
- **unit**，空闲存活时间单位
- **workQueue**，任务队列，用于存放已提交的任务。满则创建救急线程
- **threadFactory**，线程工厂，用于创建线程执行任务
- **handler**，拒绝策略，当线程池处于饱和时，使用某种策略来拒绝任务提交

**生命周期流转**

![image-20240328092321582](Redis.assets/image-20240328092321582.png)

**执行流程**

![](https://img-blog.csdnimg.cn/20210518151544449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMDkzMjU1,size_16,color_FFFFFF,t_70#pic_center)

1）如果workerCount < corePoolSize ==> 创建线程执行提交的任务
		2）如果workerCount >= corePoolSize && 阻塞队列未满 ==> 添加至阻塞队列，等待后续线程来执行提交地任务
		3）如果workerCount >= corePoolSize && workerCount < maxinumPoolSize && 阻塞队列已满 ==> 创建非核心线程执行提交的任务
		4）如果workerCount >= maxinumPoolSize && 阻塞队列已满 ==> 执行拒绝策略

![image-20240520145614023](Redis.assets/image-20240520145614023.png)

【建议】不同类型的业务任务尽量使用不同的线程池

**应用场景**

1.网购商品秒杀

2.云盘文件上传和下载

3.12306网上购票系统等

**使用**

只要有并发的地方、任务数量大或小、每个任务执行时间长或短的都可以使用线程池;
只不过在使用线程池的时候,注意一下设置合理的线程大小即可;

![image-20240520150653313](Redis.assets/image-20240520150653313.png)



![image-20240520151118373](Redis.assets/image-20240520151118373.png)

现在基本不使用了。

![image-20240520152115875](Redis.assets/image-20240520152115875.png)

![image-20240520155548456](Redis.assets/image-20240520155548456.png)



![image-20240520160441323](Redis.assets/image-20240520160441323.png)



![image-20240520160858725](Redis.assets/image-20240520160858725.png)

Semaphore：通常**用于那些资源有明确访问数量限制的场景**，常用于限流。

![image-20240520162149543](Redis.assets/image-20240520162149543.png)

举个例子：

~~~Java
import javax.swing.tree.TreeNode;
import java.util.*;

import java.util.concurrent.Semaphore;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class User {

    private static final Semaphore semaphore = new Semaphore(1); // 创建一个具有1个许可的信号量
    static AtomicInteger t=new AtomicInteger(1);

    public static void main(String[] args) {
        Thread t1 = new Thread(() -> print(), "Thread-A");
        Thread t2 = new Thread(() -> print(), "Thread-B");
        t1.start();
        t2.start();
    }

    private static void print() {
        for (int i = 0; i < 50; ) {
            try {
                semaphore.acquire(); // 获取一个许可
                String name = Thread.currentThread().getName();
                if ((t.get()%2==1 && name.equals("Thread-A")) || (t.get()%2==0 && name.equals("Thread-B"))) {
                    System.out.println(name+" "+t.get());
                    i++;
                    t.incrementAndGet();
                }
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            } finally {
                semaphore.release(); // 释放一个许可
            }
        }
    }
}


~~~

Semaphore和线程池的区别

- 使用Semaphore，实际**工作线程**由开发者自己创建；使用线程池，实际工作线程由线程池创建

- 使用Semaphore，并发线程的控制必须手动通过**acquire()和release()函数**手动完成；使用线程池，并发线程的控制由线程池自动管理

- 使用Semaphore**不支持设置超时和实现异步访问**；使用线程池则可以实现超时和异步访问，通过提交一个Callable对象获得Future，从而可以在需要时调用Future的方法获得线程执行的结果，同样利用**Future也可以实现超时**

  ~~~Java
  import java.util.concurrent.Callable;
  
  public class MyCallableTask implements Callable<String> {
      @Override
      public String call() throws Exception {
          // 模拟一些耗时的计算或I/O操作
          Thread.sleep(2000);
          return "Result of the task";
      }
  }
  import java.util.concurrent.ExecutorService;
  import java.util.concurrent.Executors;
  import java.util.concurrent.Future;
  import java.util.concurrent.TimeUnit;
  
  public class ThreadPoolExample {
      public static void main(String[] args) {
          // 创建一个固定大小的线程池
          ExecutorService executorService = Executors.newFixedThreadPool(2);
  
          // 提交Callable任务并获取Future对象
          Future<String> future = executorService.submit(new MyCallableTask());
  
          try {
              // 尝试在5秒内获取任务结果
              String result = future.get(5, TimeUnit.SECONDS);
              System.out.println("Task completed: " + result);
          } catch (Exception e) {
              // 如果任务超时或发生异常
              System.out.println("Task timed out or interrupted: " + e.getMessage());
              // 取消任务
              future.cancel(true);
          } finally {
              // 关闭线程池
              executorService.shutdown();
          }
      }
  }
  
  ~~~
  
  

## 9、数据库连接池

为数据库连接建立一个**“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。**

数据库连接池负**责分配、管理和释放数据库连接**，它允许应用程序**重复使用一个现有的数据库连接，而不是重新建立一个。**

数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由**最小数据库连接数来设定的**。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的**最大数据库连接数量限定了这个连接池能占有的最大连接数**，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。
优点：资源重用、更快的系统反应速度、新的资源分配手段、统一的连接管理，避免数据库连接泄露

## 10、请你介绍下 JVM 内存模型，分为哪些区域？各区域的作⽤是什么？

![image-20240328102300380](Redis.assets/image-20240328102300380.png)

分**线程共有、线程私有**。

- 程序计数器：字节码解释器可以改变程序计数器来**读取指令，控制代码**的流程；多线程的话，**能记录线程当前运⾏的位置**（唯⼀⼀个不出现outofmemoryerror的数据区） 

- 虚拟机栈：1）为**调⽤java⽅法**服务的，每⼀个被**线程执⾏的⽅法**，为该栈中的栈帧，即每个⽅法对应⼀个栈帧。 

  2）调⽤⼀个⽅法，就会向栈中压⼊⼀个栈帧；3）⼀个⽅法调⽤完成，就会把该栈帧从栈中弹出；若栈内存⼤⼩不允许动态扩容，可能会出现StackOverflowerror；如果栈内存⼤⼩可以动态扩容，则可能出现 **outofmemoryerror**； 

  - 栈内存变大导致线程数变少（非越大越好），默认栈内存1024k
  - 方法内的局部变量是否安全？
    - 如果方法内局部变量**没有逃离方法的作用范围**，它是线程安全的
    - 如果是**局部变量引用了对象，并逃离方法的作用范围**，需要考虑线程安全

  - 栈内存溢出
    - 栈帧过多导致栈内存溢出
    - 栈帧过大（方法参数和局部变量）导致栈内存溢出

  - 堆栈区别
    - 栈内存一般会用来存储局部变量和方法调用，但堆内存是用来存储Java对象和数组的的。**堆会GC垃圾回收**，而栈不会。
    - 栈内存是线程私有的，而堆内存是线程共有的。
    - 两者异常错误不同，但如果栈内存或者堆内存不足都会抛出异常。
      - 栈空间不足:java.lang.StackOverFlowError。
      - 堆空间不足:java.lang.OutOfMemoryErkor。

- 本地⽅法栈：**native⽅法**通过这个实现 

- 堆：Java堆是Java虚拟机所管理内存中最⼤的⼀块，**存放实例对象与数组**；容易出现**outofmemoryerror**

  - 年轻代+老年代
  - 年轻代被划分为三部分，Eden区和两个大小严格相同的Survivor区。根据JVM的策略，在经过几次垃圾收集后，仍然存活于Survivor的对象将被移动到老年代区间。
  - 老年代主要保存生命周期长的对象，一般是一些老的对象

- ⽅法区：**存放已被加载的类信息、常量、静态变量**、即时编译器编译后的代码数据。即**永久代**，在**jdk1.8**中不存在⽅法区了，被称为**元空间（Metaspace）**--->放在本地内存中。线程共享区域、**虚拟机启动时创建，关闭虚拟机时释放**

  原⽅法区分成两部分；

  - 1：加载的类信息
  - 2：运⾏时常量池；

  运行时常量池

  - 常量池:可以看作是一张表，**虚拟机指令根据这张常量表找到要执行的类名方法名、参数类型、字面量**等信息

  - 当类被加载，它的常量池信息就会放入**运行时常量池，并把里面的符号地址变为真实地址**

    

![image-20240525142854502](Redis.assets/image-20240525142854502.png)

直接内存：

- 并不属于JVM中的内存结构，不由JVM进行管理。是**虚拟机**的系统内存

- 常见于 **NIO 操作时，用于数据缓冲区，分配回收成本较高，但读写性能高**，不受 JVM 内存回收管理

  ![image-20240525164346760](Redis.assets/image-20240525164346760.png)



## 11、什么是双亲委派模式？有什么作⽤？

双亲委派保证类加载器，自下而上的委派，又自上而下的加载，保证每一个类在各个类加载器中都是同一个类。

**具体来说，当⼀个类加载器需要加载某个类时，它⾸先会委派给它的⽗类加载器去加载该类。如果⽗类加载器⽆法找到该类，则再将加载任务委派给它的⽗类加载器，直到最终委派到顶层的启动类加载器。如果顶层的启动类加载 器仍然⽆法找到该类，则会抛出 ClassNotFoundException 异常。 **

**这样做的好处是：防⽌内存中出现多份同样的字节码。**

双亲委派模式的作⽤：

- 保证 JVM 中**每个类只会被加载⼀次，避免重复加载**。当⼀个类被加载后，它会被**缓存在 JVM **的内存中，以便之后的使⽤。 
- 如果**不**采⽤双亲委派模式，可能会导致**同⼀个类被多次加载**，从⽽浪费⼤量的内存资源。 
- 此外，双亲委派模式还可以保证**类的安全性**，因为如果⼀个类是由⽤户⾃定义的类加载器加载的，那么它并不能访问由系统类加载器或其它更⾼级别的类加载器加载的类。对于⼀些核⼼类，例如 java.lang.Object、 java.lang.String 等，它们都是由启动类加载器加载的，因此也可以保证它们的正确性和安全性。

------

类加载器：JVM只会运行二进制文件，类加载器的作用就是**将字节码文件加载到JVM**中，从而让Java程序能够启动起来。

![image-20240525205008161](Redis.assets/image-20240525205008161.png)

<img src="Redis.assets/image-20240525205908055.png" alt="image-20240525205908055" style="zoom: 67%;" />

<img src="Redis.assets/image-20240525210525127.png" alt="image-20240525210525127" style="zoom: 67%;" />

<img src="Redis.assets/image-20240525211413640.png" alt="image-20240525211413640" style="zoom:50%;" />



## 11、怎么打破双亲委派模式

类的加载方式默认是双亲委派，如果我们有一个类想要通过自定义的类加载器来加载这个类，而不是通过系统默认的类加载器，说白了就是不走双亲委派那一套。

1、自定义类加载器 ，重写loadclass方法。典型的打破双亲委派模型的框架和中间件有**tomcat**与**osgi**
2、SPI机制绕开loadclass 方法。当前线程设定关联类加载器。

当然这里要注意一下，Object.class这是对象的顶级类，改变类的类加载器的时候要注意，如果全部改了，Object.class就找不到了，加载不了了。所以呢，这里重写的时候，要注意分类解决，把你**想要通过自定义类加载器加载的和想通过默认类加载器加载的分隔开**。

如果不想打破双亲委派模型，就重写**ClassLoader类中的findClass()**方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。

由于java中无法直接引用BootstrapClassLoader，所以在初始化TestClassLoader时，传入parent为null，也就是TestClassLoader的父类加载器设置为BootstrapClassLoader。

双亲委派的逻辑在 **loadClass**，由于现在的类加载器的关系为TestClassLoader —>**BootstrapClassLoader**，所以TestClassLoader中无需重写loadClass。

![](https://img-blog.csdnimg.cn/20210601230727770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNjU4NjEyMA==,size_1,color_FFFFFF,t_70#pic_center)

## 12、常⻅的垃圾回收算法有⼏种类型？他们对应的优缺点是什么？

**什么是垃圾？**

如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾如果定位了垃圾，则有可能会被垃圾回收器回收。

**怎么定位垃圾？**

- 引用计数法：循环引用，引用计数法失效
- 可达性分析算法
  - Java 虚拟机中的垃圾回收器采用**可达性分析来探索所有存活**的对象
  - 扫描堆中的对象，看是否能够沿着 **GC Root 对象 为起点的引用链**找到该对象，找不到，表示可以回收
    - 那些可以作为GC Root
      - **虚拟机栈(栈帧中的本地变量表)中引用的对象**
      - **方法区中类静态属性引用的对象**
      - **方法区中常量引用的对象**
      - 本地方法栈中 JNI(即一般说的 Native 方法)引用的对象

------



**标记-清除算法、复制算法、标记-整理算法、分代收集算法**

**标记-清除算法 **

标记—清除算法包括两个阶段：“标记”和“清除”。 标记阶段：确定所有要回收的对象，并做标记。 清除阶段：将标记阶段确定不可⽤的对象清除。 

优点：算法简单明了，实现容易 

缺点： 标**记和清除的效率都不高。 会产⽣⼤量的碎⽚，⽽导致频繁**的回收。 

**复制算法** 

内存分成⼤⼩相等的两块，每次使⽤其中⼀块，当垃圾回收的时候， 把存活的对象复制到另⼀块上，然后把这块内存整个清理掉。 

缺点： 需要**浪费额外的内存作为复制区。 当存活率较⾼时，复制算法**效率会下降。 

**标记-整理算法**

标记—整理算法不是把存活对象复制到另⼀块内存，⽽是把存活对象往内存的⼀端移动，然后直接回收边界以外的 内存。 

缺点： 算**法复杂度⼤，执⾏步骤**较多 

**分代收集算法 **

⽬前⼤部分 JVM 的垃圾收集器采⽤的算法。根据对象存**活的⽣命周期将内存划分为若⼲个**不同的区域。⼀般情况下将堆区划分为**新⽣代（ Young Generation 和⽼年代（ Tenured Generation ），永久代（ Permanet Generation）**。 

⽼年代的特点是每次垃圾收集时只有少量对象需要被回收，⽽新⽣代的特点是每次垃圾回收时都有⼤量的对象需要被回收，那么就可以根据**不同代的特点采取最适合的**收集算法。 

Young：存放新创建的对象，对象⽣命周期⾮常短，⼏乎⽤完可以⽴即回收，也叫 **Eden 区**。 

Tenured： young 区多次回收后存活下来的对象将被移到 tenured 区，也叫 **old **区。 

Perm：永久**代，主要存储加载的类信息，⽣命周期⻓，⼏乎不会被**回收。

缺点： 算**法复杂度⼤，执⾏**步骤较多。

<img src="Redis.assets/image-20240525213548925.png" alt="image-20240525213548925" style="zoom: 67%;" />



垃圾回收器：串行垃圾收集器、并行垃圾收集器、CMS（Concurrent Mark Sweep）(并发)垃圾收集器 、G1垃圾收集器（jdk9之后默认使用G1）

cms:标记清除；G1：**标记整理算法**

![image-20240525214606516](Redis.assets/image-20240525214606516.png)

![image-20240525221432259](Redis.assets/image-20240525221432259.png)



**强、软、弱、虚引用区别**

软\弱引用就是通过SoftReference和WeakReference这两个类来实现定义强弱引用的

![image-20240525222316561](Redis.assets/image-20240525222316561.png)



## 13、并发和并⾏有什么区别？同步和异步有什么区别？

**并发**：指多个任务同时在执⾏，但是它们并不是在同⼀时刻执⾏，⽽是通过**快速切换上下⽂来模拟同时执⾏**，优秀的并发可以⽆限逼近并⾏，但⽆法完全做到并⾏。 

例如，在⼀个 Web 服务器上，多个⽤户访问同⼀个⽹站，服务器会并发地处理这些请求，同时响应每个请求，但是在某⼀时刻只有⼀个请求被处理； 

在单核cpu下，多个线程轮流使用cpu称为并发。

在多核cpu下，。。。。。。。。一个或多个cpu。。。。

**并⾏**：指多个任务同时在执⾏，并且它们真正地同时执⾏，通常需要多个 CPU 或者多台计算机协同⼯作。 

例如，在⼀个分布式计算系统中，不同的计算节点可以同时执⾏不同的任务，并在完成任务后将结果汇总，以加速 计算的过程。

在多核cpu下，线程和cpu是一对一。。。

**同步**：指调⽤某个函数或⽅法时，程序必须等待函数或⽅法执⾏完毕才能继续往下执⾏。 

最熟知的便是使⽤同步机制来控制多个线程之间的访问，如在 Java 中的 synchronized 关键字可以确保同⼀时间 只有⼀个线程可以访问某个对象的临界区，避免了多个线程同时修改同⼀个对象导致的数据不⼀致问题；

**异步**：指调⽤某个函数或⽅法时，程序可以继续往下执⾏，不必等待函数或⽅法执⾏完毕。当函数或⽅法执⾏完毕 后，程序会得到⼀个通知或回调来处理结果。在 Java 中**可以使⽤ CompletableFuture 类来异步执⾏某个任务**，从⽽提⾼程序的性能。 

虽然并发和并⾏、同步和异步都是计算机领域中常⽤的概念，但是它们的区别还是很明显的。并发和并⾏关注的是任务的执⾏⽅式，同步和异步则关注的是数据的处理⽅式。



## 14、什么是 BIO、NIO、AIO？写的不好

**BIO、NIO、AIO 都是 Java 中网络编程的 I/O 模型。** 

BIO（Blocking IO ）是JDK1.4之前的传统IO模型，特点就是同步阻塞等待数据，直到数据读取完毕才会返回结果， **线程会⼀直阻塞在 read/write ⽅法上，不能处理其他的 IO 请求，它的并发性能⽐较差**。 

NIO（Non-Blocking IO）是Java 1.4 之后新增的 IO 模型，它⽀持同步⾮阻塞式的 IO 操作。NIO 采⽤了**多路复⽤器来处理 IO 请求，通过⼀个线程处理多个 IO 请求，实现了⾼并发处理**。NIO 主要有三个核⼼概念：Selector、 Channel、Buffer。Selector 负责监听多个 Channel 上的事件，Channel 可以理解为对原始 IO 的封装，Buffer则是对数据的封装。 

AIO（Asynchronous IO）是Java 1.7 之后新增的 IO 模型，它⽀持异步⾮阻塞 IO 操作。与 NIO 不同的是，AIO 在 进⾏读写操作时不需要像 NIO ⼀样⼀直轮询，⽽是通过**回调函数的⽅式在数据准备好后通知应⽤程序进行数据的读取**，这样可以更加⾼效地利⽤系统资源，提⾼吞吐量。但是 AIO 在处理⼩⽂件和⼩数据量时的性能并不如 NIO

![image-20240328105608795](Redis.assets/image-20240328105608795.png)

理解：

| BIO 同步阻塞 IO，即打算约⼥神，给⼥神发短信后，没⻅到⼥神就⼀直等在宿舍楼下。 |
| ------------------------------------------------------------ |
| NIO 同步⾮阻塞 IO，即打算约⼥神，给⼥神发短信后，没⻅到⼥神就⼀直发短信。 |
| NIO java中的 NIO，就是打算约⼥神，你让宿管⼤妈去挨个看每⼀个下楼的妹⼦，⼥神下楼了⼤妈就通知你。 |
| AIO 就是打算约⼥神，你发完短信，你就去玩游戏了，⼥神下楼了，发短信给你，你才出现。 |



## 15、线程的⽣命周期是什么，线程有⼏种状态，什么是上下⽂切换？

线程状态：new、Runnable（start）、terminated、blocked、waiting、Timed_waited。

**上下文**：cpu当前的寄存器信息保存、恢复上下文的过程。通过让cpu恢复过去的记忆，回到过去的状态。

先创建2个线程的初始上下文，并存入到相应的内存颗粒上。经过内核调度，先让线程一运行，也就是说使用线程一的上下文来设置cpu寄存器，其中eip寄存器让cpu跳转到线程一的方法上运行。这时发生时钟中断，cpu跳转到内核代码，内核将当前代码保存到线程一的内存颗粒上。这时，使用线程二的上下文来设置cpu寄存器，eip寄存器让cpu跳转到线程二的方法上运行。

------

线程通常有五种状态：**创建，就绪，运⾏、阻塞和死亡状态**。

![image-20240328110106604](Redis.assets/image-20240328110106604.png)

新建状态（New）：新创建了⼀个线程对象。 

就绪状态（Runnable）：线程对象创建后，其他线程调⽤了该对象的start⽅法。该状态的线程位于可运⾏线程池中，变得可运⾏，等待获取 CPU 的使⽤权。 

运⾏状态（Running）：就绪状态的线程获取了 CPU，执⾏程序代码。

阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃 CPU 使⽤权，暂时停⽌运⾏。直到线程进⼊就绪 状态，才有机会转到运⾏状态。 

死亡状态（Dead）：线程执⾏完了或者因异常退出了 run ⽅法，该线程结束⽣命周期。

其中阻塞的情况⼜分为三种：

- **等待阻塞**：运⾏的线程执**⾏wait⽅法，该线程会释放占⽤的所有资源**，JVM 会把该线程放⼊“等待池”中。进⼊ 这个状态后，是不能⾃动唤醒的，必须依靠其他线程调⽤ notify 或 notifyAll ⽅法才能被唤醒，wait 是 object 类的 ⽅法 
- **同步阻塞**：**运行的线程在获取对象的同步锁时，若该同步锁被别的线程占⽤，则 JVM 会把该线程放⼊“锁池” 中**。
- **其他阻塞**：运⾏的线程执⾏**sleep 或 join ⽅法，或者发出了 I/O 请求时，JVM 会把该线程置为阻塞状态**。当 sleep 状态超时、join 等待线程终⽌或者超时、或者 I/O 处理完毕时，线程重新转⼊就绪状态。sleep 是 Thread 类 的⽅法。

## 15、线程

![image-20240517210758181](Redis.assets/image-20240517210758181.png)

![image-20240517210918749](Redis.assets/image-20240517210918749.png)



![image-20240517210940223](Redis.assets/image-20240517210940223.png)

线程退出：

1.打标记，volatile(读写屏障，先读（阻止下方其他读操作越过屏障排到volatile变量读之上）后写（阻止上方其他写操作越过屏障排到voltile变量之下），防止指令重排序)

![image-20240605150440979](Redis.assets/image-20240605150440979.png)

<img src="Redis.assets/image-20240605150632252.png" alt="image-20240605150632252" style="zoom: 67%;" />

![image-20240605150736445](Redis.assets/image-20240605150736445.png)

2.interrupted

------

![image-20240520082322562](Redis.assets/image-20240520082322562.png)

![image-20240520084640535](Redis.assets/image-20240520084640535.png)

![image-20240811155913074](C:\Users\耀\AppData\Roaming\Typora\typora-user-images\image-20240811155913074.png)

死锁产生的四个必要条件是：

1. **互斥条件（Mutual Exclusion）**：资源不能被多个线程同时占有。任何时候，一个资源只能被一个线程持有。
2. **持有和等待条件（Hold and Wait）**：线程至少持有一个资源，并且正在等待获取额外的资源，而该资源目前被其他线程持有。
3. **非抢占条件（No Preemption）**：线程持有的资源在未使用完之前不能被其他线程强行抢占。
4. **循环等待条件（Circular Wait）**：存在一个线程集合，每个线程都在等待下一个线程所持有的资源，形成一个循环等待链。

只有当这四个条件同时满足时，死锁才会发生。为了预防死锁，必须至少破坏其中一个条件。

![image-20240520085808390](Redis.assets/image-20240520085808390.png)

![image-20240520091121176](Redis.assets/image-20240520091121176.png)

![image-20240520092042093](Redis.assets/image-20240520092042093.png)





## 16、synchronized 关键字是什么，有什么作⽤？

synchronized 是 Java 中的⼀个关键字，⽤来实现**同步锁**。 

它可以修饰**⽅法或代码块，保证同⼀时刻只有⼀个线程可以执⾏被修饰的部分** 

synchronized 的作⽤有以下⼏点： 

- 保证数据的**原⼦性和可⻅性**，防⽌多线程操作导致的数据不⼀致。 

- **防止指令重排序**，保证代码执⾏的顺序和预期⼀致。 （同vatilate）

- **实现线程间的通信**，通过 wait 和 notify ⽅法来实现线程的等待和唤醒。 

synchronized的使⽤⽅式有以下⼏种： 

- 修饰⾮静态⽅法，锁对象是当前实例对象 

- 修饰静态⽅法，锁对象是当前类对象 

- 修饰代码块，锁对象是括号⾥指定的对象 

synchronized 和其他同步⼯具（如 ReentrantLock）相⽐，有以下优缺点： 

- 优点：**简单易用，不需要手动释放锁。 **
- 缺点：不灵活，不能设置超时时间、中断等；效率低，每次都要进⼊内核态获取锁；不可重⼊，同⼀个线程在获取到锁后还要再次获取锁会造成死锁

------

![image-20240518080509328](Redis.assets/image-20240518080509328.png)

![image-20240518081939770](Redis.assets/image-20240518081939770.png)

###synchronized的锁升级过程？

无锁--》偏向锁--》轻量级锁--》重量级锁

偏向锁：

轻量级锁：在多线程交替执行同步块的情况下，可以避免重量级锁引起的性能损耗

中间态：自旋锁：默认自旋10次，JVM会认为自旋获得锁的线程，会增加自旋的时间

锁消除：不存在竞争情况下，会进行synchronized的消除

锁粗化：JVM会探测到一连串细小的操作都使用同一对象加锁，将同步代码块的范围放大，放到这串操作的外面，只需加一次锁即可



![image-20240518083110814](Redis.assets/image-20240518083110814.png)



![image-20240518083929983](Redis.assets/image-20240518083929983.png)

![image-20240518090150780](Redis.assets/image-20240518090150780.png)

AQS（AbstractQueuedSynchronizer,抽象队列同步器），构建锁或者其他同步组件的基础框架。

![image-20240518091126044](Redis.assets/image-20240518091126044.png)

101



## 17、<font color=red>设计模式可以分为哪⼏类？⼀共有多少种主流的设计模式？场景？</font>

- 创建型模式：这类模式关注对象创建的机制，包括单例模式、⼯⼚模式、抽象⼯⼚模式、建造者模式和原型模 式等。 

- 结构型模式：这类模式关注对象之间的组合关系，包括适配器模式、装饰器模式、代理模式、组合模式、桥接 模式、外观模式和享元模式等。 

- ⾏为型模式：这类模式关注对象之间的通信⽅式和协作⽅式，包括模板⽅法模式、策略模式、命令模式、职责 链模式、状态模式、观察者模式、中介者模式和访问者模式等。 

  ⽬前主流的设计模式有23种，它们分别是： 

- 单例模式 :确保类只有⼀个实例，并提供全局访问点。

  ⼯⼚⽅法模式 :每个具体的类都有⾃⼰的⼯⼚⽅法，负责创建对象实例。

  抽象⼯⼚模式 :⼀组相关或相互依赖的对象，由⼀个抽象⼯⼚对象负责创 建。

  建造者模式 

  原型模式 

  适配器模式 

  装饰器模式 

  代理模式 

  外观模式 

  桥接模式 

  组合模式 

  享元模式 

  策略模式 

  模板⽅法模式 

  观察者模式 

  迭代器模式 

  职责链模式 

  命令模式 

  备忘录模式 

  状态模式 

  访问者模式 

  中介者模式 

  解释器模式

## 18、什么是⼯⼚模式？使⽤⼯⼚模式有什么好处？⼯⼚模式有哪些分类？各 ⾃的应⽤场景是什么？

- ⼯⼚模式


​	把对象的构造交给⼀个类,这样在对象构造过程中,调⽤者不需要知道对象的产⽣过程。降低了代码的耦合度，同时体现了⾯向对象的封装的特征。

​	好处：松耦合 封装 可拓展 复⽤

**简单⼯⼚模式** （⼀个⼯⼚⽣产所有的对象 ）

​	如果它负责的对象太多，简单⼯⼚容易庞⼤，变成超级类 

​	简单⼯⼚的拓展是竖向拓展（拓展需要访问⼯⼚内部，职责不够单⼀） 

​	因此，他适合在'简单场景' - 对象少且固定

**⼯⼚⽅法模式** （ ⼀个⼯⼚⼀个对象 ）

​	⼯⼚⽅法是横向拓展，由于⼯⼚对象1对1，耦合度没有任何减少，要⽣产类就要知道那个对应的⼯⼚ 

​	当需要⽣产新的产品时，⽆需更改既有的⼯⼚，只需要添加新的⼯⼚即可。保持了⾯向对象的可扩展性(纵 向，横向都很不错)，符合开闭原则。 

​	因此，⼯⼚⽅法模式适⽤于对象多⽽且可能增加的场景

**抽象⼯⼚模式** （ 抽象接⼝⼯⼚实现 ）

​	抽象⼯⼚是定义了⼀个接⼝，然后由具体⼯⼚去实现抽象⽅法，突出特点就是运⽤了多态，耦合够松。 

​	缺点也很明显，在接⼝不变的情况下，⽆论是横向拓展性还是松耦合都很好，但是⼀旦接⼝有新的功能增加， 所有的⼯⼚实现都需要纵向拓展。即横向拓展能⼒强，但是纵向拓展能⼒=0 

​	因此，抽象⼯⼚模式适合产品族（即有相似属性）的⽣产

## 19、设计模式是什么？为什么要学习和使⽤设计模式？

设计模式：是⼀套经过反复使⽤的代码设计经验，⽬的是为了重⽤代码、让代码更容易被他⼈理解、保证代码可靠 性。  

项⽬中合理地运⽤设计模式可以完美解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式描述 了⼀个在我们周围不断重复发⽣的问题，以及该问题的核⼼解决⽅案，这也是它能被⼴泛应⽤的原因。 设计模式分为三⼤类

设计模式分为三⼤类：

创建型模式：共5种：⼯⼚⽅法模式、抽象⼯⼚模式、单例模式、建造者模式、原型模式 

结构型模式：共7种：适配器模式、装饰器模式、代理模式、桥接模式、外观模式、组合模式、享元模式 

⾏为型模式：共11种：策略模式、模板⽅法模式、观察者模式、责任链模式、访问者模式、中介者模式、迭 代器模式、命令模式、状态模式、备忘录模式、解释器模式

## 20、什么是单例模式？使⽤单例模式有什么好处？有哪些常⽤的单例模式实现⽅式？各⾃的应⽤场景是什么？

**单例模式**是⼀种设计模式，它的⽬的是**保证⼀个类只有⼀个实例**，并提供⼀个**全局的访问点**。使⽤单例模式可以**避免多次创建对象，节省内存空间**，同时也可以保证**数据的⼀致性**。在开发过程中使⽤单例模式有以下好处：

1. **节省内存空间**。单例模式只创建⼀个实例，避免了多次创建对象所造成的内存消耗。 

2. **简化代码**。单例模式提供了⼀个**全局的访问点**，可以⽅便地调⽤实例的⽅法，避免了重复的代码。 
3. **保证数据的⼀致性**。由于只有⼀个实例，可以**避免并发访问时数据不⼀致**的问题。

单例模式在开发中有许多适⽤的场景，如：

![image-20240514101608541](Redis.assets/image-20240514101608541.png)

![image-20240514101619111](Redis.assets/image-20240514101619111.png)

![image-20240514101632919](Redis.assets/image-20240514101632919.png)

## 21、JVM实践

![image-20240526085749985](Redis.assets/image-20240526085749985.png)

![image-20240526091115059](Redis.assets/image-20240526091115059.png)

![image-20240526091142500](Redis.assets/image-20240526091142500.png)

![image-20240526091216019](Redis.assets/image-20240526091216019.png)

<img src="Redis.assets/image-20240526093420155.png" alt="image-20240526093420155" style="zoom: 67%;" />

<img src="Redis.assets/image-20240526094046837.png" alt="image-20240526094046837" style="zoom: 67%;" />

![image-20240526094648969](Redis.assets/image-20240526094648969.png)

对应Linux命令：

top

![image-20240526094829790](Redis.assets/image-20240526094829790.png)

![image-20240526094917659](Redis.assets/image-20240526094917659.png)

![image-20240526094959596](Redis.assets/image-20240526094959596.png)

转十六进制

![image-20240526095023812](Redis.assets/image-20240526095023812.png)

在日志中找当前线程对应的信息

##22、String, StringBuffer and StringBuilder

![image-20240808111714297](C:\Users\耀\AppData\Roaming\Typora\typora-user-images\image-20240808111714297.png)

## 23、非受检异常和受检异常

![](https://pdai.tech/images/java/java-basic-exception-1.png)

- **可查异常**（编译器要求必须处置的异常）：

正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。

除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。

- **不可查异常**(编译器不要求强制处置的异常)

包括运行时异常（RuntimeException与其子类）和错误（Error）。

## 24、讲一下wait和notify这个为什么要在synchronized?

**监视器（Monitor）所有权**：在Java中，每个对象都有一个监视器（Monitor），线程可以通过`synchronized`关键字来获取这个监视器的所有权。

**数据一致性**：在同步代码块或方法中，可以防止多个线程同时访问共享资源，从而避免数据竞争和不一致的状态。

**避免死锁和竞态条件**：例如，一个线程可能试图在另一个线程调用`notify()`之前调用`wait()`，如果没有同步，这将导致线程无限期地等待。














# 计算机基础

## 计网

## 1、<font color=red>简述计算机⽹络七层模型和各⾃的作⽤？</font>



![image-20240329195126026](Redis.assets/image-20240329195126026.png)

每⼀层都专注做⼀件事情，并且每⼀层都需要使⽤下⼀层提供的功能⽐如传输层需要使⽤⽹络层提供的路由和寻址功能，这样传输层才知道把数据传输到哪⾥去。

## 2、HTTP 是哪⼀层的协议？简述它的作⽤？

![image-20240329195044247](Redis.assets/image-20240329195044247.png)

## 3、HTTP 有哪些常⻅的状态码？

![image-20240329192913926](Redis.assets/image-20240329192913926.png)

![image-20240329192950268](Redis.assets/image-20240329192950268.png)

## 4、TCP 和 UDP 协议有什么区别，分别适⽤于什么场景

TCP 和 UDP 是计算机⽹络中两种常⽤的传输层协议，⽤于实现可靠传输和⽆连接传输。 

TCP（Transmission Control Protocol）是⼀种**⾯向连接的、可靠的传输协议**。它通过**三次握⼿四次挥⼿**进⾏连接和断开链接，保证数据的**可靠性、完整性和顺序性**，具有较⾼的传输效率。 TCP 协议适⽤于**要求可靠传输的场景，如⽂件传输、电⼦邮件传输**等。 

![image-20240529101256710](Redis.assets/image-20240529101256710.png)

![image-20240529101310559](Redis.assets/image-20240529101310559.png)

![image-20240529101332319](Redis.assets/image-20240529101332319.png)

![image-20240529101346558](Redis.assets/image-20240529101346558.png)



##5、HTTP 协议中 GET 和 POST 有什么区别？分别适⽤于什么场景？

![image-20240329170211065](Redis.assets/image-20240329170211065.png)

**GET 和 POST 之所以产⽣区别，是因为浏览器/服务器的限制**。

## 6、简述 TCP 三次握手、四次挥手的流程？为什么需要三次握手？为什么需要四次挥手

**TCP（Transmission Control Protocol）是⼀种⾯向连接的协议，为了保证数据传输的可靠性，TCP 使⽤了三次握⼿和四次挥⼿的过程。**

三次握⼿的过程如下：

1. 第⼀次握⼿：客户端向服务器发送 SYN 报⽂，请求建⽴连接。 
2. 第⼆次握⼿：服务器收到客户端的 SYN 报⽂，向客户端发送 SYN+ACK 报⽂，表示可以建⽴连接。 
3. 第三次握⼿：客户端收到服务器的 SYN+ACK 报⽂，向服务器发送 ACK 报⽂，表示连接已经建⽴。

![image-20240329193253075](Redis.assets/image-20240329193253075.png)

**为什么需要三次握⼿？**

三次握⼿的⽬的是为了确认双⽅的收发能⼒和同步初始序列号。

**四次挥⼿的过程如下：**

第⼀次挥⼿：客户端向服务器发送 FIN 报⽂，请求关闭连接。 

第⼆次挥⼿：服务器收到客户端的 FIN 报⽂，向客户端发送 ACK 报⽂，表示收到关闭请求。 

第三次挥⼿：服务器向客户端发送 FIN 报⽂，请求关闭连接。 

第四次挥⼿：客户端收到服务器的 FIN 报⽂，向服务器发送 ACK 报⽂，表示收到关闭请求。

![image-20240329193414899](Redis.assets/image-20240329193414899.png)

**为什么需要四次挥⼿？**

四次挥⼿的⽬**的是为了保证数据的完整性和可靠性**。在关闭连接之前，双⽅需要确保所有数据都已经传输完毕，因此需要通过四次挥⼿的过程进⾏确认和处理。

**总结：三次握⼿的本质是确认通信双⽅收发数据的能⼒ ，四次挥⼿的⽬的是关闭⼀个连接。**

举例：

![image-20240329193608836](Redis.assets/image-20240329193608836.png)

## 7、<font color=red>HTTP协议为什么是无状态的？如何让HTTP“有状态”？</font>

无状态是指**协议对于事务处理没有记忆能力，不能保存每次客户端提交的信息**，即当服务器返回应答之后，这次事务的所有信息就都丢掉了。**如果用户发来一个新的请求，服务器也无法知道它是否与上次的请求有联系。**

一个包含多图片的网页的浏览：

（1）建立连接，客户端发送一个请求，服务器端返回一个HTML页面（这里的页面只是一个纯文本的页面，也就是我们写的HTML代码），关闭连接；

（2）浏览器解析HTML文件，遇到图片标记得到url，这时，客户端和服务器再建立连接，客户端发送一个图片请求，服务器返回图片应答，关闭连接。【这里又涉及到无状态定义：对于服务器来说，这次的请求虽然是同一个客户端的请求但是服务器还是不知道这个是之前的那个客户端，即对于事务处理没有记忆能力】

优点：**服务器不用为每个客户端连接分配内存来记忆大量状态，也不用在客户端失去连接时去清理内存，节省服务器端资源，以更高效地去处理业务**。

缺点：**缺少状态意味着如果后续处理需要前面的信息，则客户端必须重传，这样可能导致每次连接每次连接传送的数据量增大。**

解决HTTP无状态的方法：

四种会话跟踪技术：

- **COOKIE**:服务器可以发送一个Cookie到客户端，客户端在后续的请求中会自动附带这个Cookie，服务器通过Cookie来识别用户。
- **Session**:服务器为每个用户创建一个会话（Session），会话中可以保存用户的状态信息。服务器会生成一个唯一的会话ID，并通过Cookie或其他方式发送给客户端，客户端在后续请求中提供这个会话ID，服务器据此恢复会话状态。
- **Token Based Authentication**：使用基于Token的认证方式，如JSON Web Tokens（JWT），服务器可以生成一个Token并通过**URL重写将其嵌入到URL**中。客户端在后续请求中提供这个Token，服务器验证Token的有效性来维持状态。（添加sessionid  ）
- **作为隐藏域嵌入HTML表单中（隐藏表单域）**:在Web表单中，可以将状态信息隐藏在表单的隐藏字段中，提交表单时这些信息会发送到服务器。

## 8、<font color=red>session的工作原理</font>

通过在**服务器端存储用户的会话信息**来实现。

当用户访问服务器时，服务器会为该用户创建一个唯一的 Session ID，并将该 ID 存储在用户的浏览器中，通常是通过设置 Cookie 的方式。服务器会将用户的会话信息存储在服务器端的内存或数据库中，并与该 Session ID 相关联。

当用户进行下一次请求时，浏览器会自动将之前存储的 Session ID 发送给服务器。服务器通过该 ID 来查找对应的会话信息，从而可以获取用户的状态和其他相关数据。服务器可以根据会话信息来判断用户的身份、权限等信息，并进行相应的处理和响应。**当用户关闭浏览器或会话超时时，会话信息会被销毁或清除。**

几个步骤：

用户访问服务器，**服务器为用户创建一个唯一的 Session ID，并将其发送给用户的浏览器**。

浏览器将 **Session ID 存储在 Cookie 中，以便下次请求时发送给服**务器。

用户进行下一次请求时，浏览器**会自动将之前存储的 Session ID** 发送给服务器。

服务器根据该 **Session ID 查找对应的会话信息，并进行相应的处理**和响应。

用户关闭浏览器或会话超时时，会话信息会被销毁或清除。

通过 **Session，服务器可以在不同的请求之间保持用户的状态，实现用户认证、用户数据的持久化**等功能

------

为什么关闭浏览器，会话结束？

关闭浏览器之后，浏览器中保存的sessionid消失，下次重新打开浏览器之后，浏览器缓存中没有这个sessionid，自然是找不到服务器中对应的session对象。session对象找不到等同于会话结束。

##9、HTTP（Hypertext Transfer Protocol）和HTTPS（Hypertext Transfer Protocol Secure）是互联网上用于数据传输的协议。它们的主要区别在于安全性。

1. **HTTP**：
   - HTTP 是一个基于**请求/响应模式的、无状态的、应用层的协**议。
   - 它使用**明文传输数据，不提供任何加密措施**，这意味着传输的数据可以被中间人轻松地截获和读取。
   - HTTP **不验证服务器的身份**，这使得用户可能与恶意服务器进行通信。
   - 尽管可以通过使用HTTP头信息（如"X-Forwarded-For"）来追踪客户端，但它不是一种安全的身份验证机制。
2. **HTTPS**：
   - HTTPS 是 HTTP 的安全版本，它使用 **SSL/TLS 协议来加密数据传输**。
   - **SSL（Secure Sockets Layer）和 TLS（Transport Layer Security）是用于加密通信的协议**，它们使用公钥和私钥对数据进行加密和解密。
   - HTTPS **验证服务器的身份，确保用户与真正的服务器通信**。
   - 它提供了一种安全的身份验证机制，使得客户端和服务器之间的通信更加安全。

##10、HTTP/2和HTTP有什么区别？

1. **二进制格式**：
   - **HTTP/1.1** 使用**文本格式传**输请求和响应头，这使得协议相对容易理解和调试，但也容易受到“空闲闲聊”问题的影响。
   - **HTTP/2** 使**用二进制格**式传输数据，这使得协议的解析更加高效，但也使得调试变得更加复杂。
2. **多路复用**：
   - **HTTP/1.1** 使用持**久连接，但在同一个 TCP 连接上，同一时间只能处理一个请求**。这导致了队头阻塞（Head-of-Line Blocking）的问题，即一个请求的处理时间过长会阻塞其他请求。
   - **HTTP/2** 引入了**多路复用，允许多个请求和响应在同一个 TCP 连接上并发传输，**解决了队头阻塞的问题。
3. **头部压缩**：
   - **HTTP/1.1** 中的请求和响应头部是每次传输都会重复的，这导致不必要的网络开销。
   - **HTTP/2** 使用 HPACK **算法对头部进行压缩，减少了网络**传输的头部大小。
4. **服务器推送**：
   - **HTTP/1.1** **不支持服务器推送**，即服务器不能主动向客户端发送数据，除非客户端先发起请求。
   - **HTTP/2** 允许**服务器在客户端请求某个资源时，主动推送其他相关的资**源，从而减少了客户端的后续请求，提高了页面加载速度。
5. **安全性**：
   - **HTTP/1.1** 使用明文传输数据，不提供任何加密措施，这意味着传输的数据可以被中间人轻松地截获和读取。
   - **HTTP/2** 默认情况下**使用 TLS 进行加密传输，这是 HTTPS** 的基础。

## 11、HTTP和TCP的联系是什么

1. **TCP**：
   - TCP 是一种传输层协议，负责在网络中的两个端点之间建立可靠的、有序的、无重复的数据传输。
   - TCP 提供流量控制、拥塞控制和错误检测等功能，以确保数据传输的可靠性和高效性。
   - TCP 建立连接、管理连接状态、传输数据和关闭连接。
2. **HTTP**：
   - HTTP 是一种应用层协议，用于在 Web 浏览器和服务器之间传输超文本数据。
   - HTTP 依赖于 TCP 提供的可靠传输服务，它使用 TCP 连接来发送请求和接收响应。
   - HTTP 定义了请求和响应的结构，包括头部（headers）和主体（body）。







# 操作系统



## 1、什么是进程和线程？它们有哪些区别和联系？

![image-20240329202141880](Redis.assets/image-20240329202141880.png)

![image-20240516225341937](Redis.assets/image-20240516225341937.png)

## 2、死锁是什么？如何预防和避免死锁？

**死锁是什么？**

多线程编程中，当两个线程为了保护两个不同的共享资源⽽使⽤了两个互斥锁，如果应⽤不当，会造成两个线程都在等待对⽅释放锁，没有外⼒的作⽤下，这些线程会⼀直互相等待，就没办法继续运⾏，这就是发⽣了死锁。

**如何预防和避免死锁？**

结合前面死锁的四个必要条件进行总结

只要破坏其中⼀个必要条件就可以避免死锁，最常⻅的并且可⾏的就是使⽤资源有序分配法，来破坏环路等待条件

例⼦1：线程之间如何避免死锁

- 线程A和线程B获取资源的顺序要⼀样 

- 线程 A 是先尝试获取资源 A，然后尝试获取资源 B 的时候 

- 线程 B 同样也是先尝试获取资源 A，然后尝试获取资源 B 

- 线程 A 和 线程 B 总是以相同的顺序申请⾃⼰想要的资源

例⼦2：MySQL 如何避免死锁

1. 设置事务等待锁的超时时间 
2. 开启主动死锁检测

其他：利⽤⼯具排查死锁问题

- java：jstack 
- C：pstack + gdb

## 3、线程间有哪些通信⽅式？

**共享内存**：多个线程共享同⼀块内存空间，通过对内存的读写操作实现线程间的信息交换。可以使⽤  synchronized 关键字或 Lock 接⼝等机制来确保线程安全。

**消息传递**：多个线程之间通过消息传递实现信息交换。在Java中，可以使⽤wait()、notify()和notifyAll()等⽅法来实现线程间消息传递。wait()⽅法会使当前线程等待，直到其他线程调⽤notify()或notifyAll()⽅法唤醒它；notify()⽅ 法会随机唤醒等待队列中的⼀个线程；notifyAll()⽅法会唤醒等待队列中的所有线程。

**信号量**：通过信号量机制实现线程间的信息交换。Java中的 Semaphore 类就是⼀个信号量实现。

**管道**：管道是⼀种特殊的流，⽤于在线程之间传递数据。Java 中的 PipedInputStream 和 PipedOutputStream 类 就是管道的实现。

**RPC调⽤**：远程过程调⽤（RPC）是⼀种跨⽹络进⾏的远程调⽤，可以实现在不同的线程或机器之间进⾏信息交换。

**线程间通信与进程间通信的区别** （扩展）

**线程是轻量级的进程，系统进⾏资源调度的基本单位是进程**，但是因为进程上下⽂切换开销太⼤，所以有了线程，节省开销。 线程本身也是共享进程的内存，上下⽂切换⽅便。 

安全性，线程间通信的安全性相对较低，需要采⽤同步机制来保证共享变量的正确性；⽽进程间通信的安全性相对较⾼，进程之间相互隔离，不会对对⽅的内存进⾏⾮法操作。

## 4、什么是零拷⻉？说⼀说你对零拷⻉的理解？

**本质：主要是因为建立了PageCache 到用户进程的虚拟地址映射（mmap file 存储在共享区域），从而避免了Pagecache和用户空间拷贝的过程。减少了一次拷贝。**

**上面是Mmap方式，sendfile方式在此基础上减少了两次上下文切换，直接从内核缓冲区拷贝到socket缓冲区。**

零拷⻉（Zero-Copy）是⼀种⾼效的数据传输技术，它可以将数据从内核空间直接传输到应⽤程序的内存空间中， 避免了不必要的数据拷⻉，从⽽提⾼了数据传输的效率和性能。

**传统IO：**

![image-20240329203213572](Redis.assets/image-20240329203213572.png)

**零拷⻉：**

![image-20240329203237084](Redis.assets/image-20240329203237084.png)

1. java 调⽤ transferTo ⽅法后，要从 java 程序的⽤户态切换⾄内核态，使⽤ DMA 将数据读⼊内核缓冲区，不会使⽤ cpu 
2. 只会将⼀些 offset 和 length 信息拷⼊ socket 缓冲区，⼏乎⽆消耗 
3. 使⽤ DMA 将 内核缓冲区的数据写⼊⽹卡，不会使⽤ cpu

整个过程仅只发⽣了⼀次⽤户态与内核态的切换，数据拷⻉了 2 次。所谓的【零拷⻉】，**并不是真正⽆拷⻉**，⽽是 在不会拷⻉重复数据到 jvm 内存中，零拷⻉的优点有

- **更少的⽤户态与内核态的切换 **
- **不利⽤ cpu 计算，减少 cpu 缓存伪共享 **
- **零拷⻉适合⼩⽂件传输**
- ![image-20240621220313633](Redis.assets/image-20240621220313633.png)

![image-20240621220634318](Redis.assets/image-20240621220634318.png)



#Linux

## 1、Linux 中的硬链接和软连接是什么，⼆者有什么区别？













## 2、CC 攻击是什么？什么叫 DDOS 攻击？什么是⽹站数据库注⼊？

![image-20240329194902277](Redis.assets/image-20240329194902277.png)

## 3、如何在 Linux 中查看系统资源使⽤情况？⽐如内存、CPU、⽹络端口。

![image-20240329194624144](Redis.assets/image-20240329194624144.png)

![image-20240329194643040](Redis.assets/image-20240329194643040.png)





# 集合

## 1、ConcurrentHashMap和Hashtable的区别

`ConcurrentHashMap` 和 `Hashtable` 的区别主要体现在实现**线程安全**的方式上不同。

**底层数据结构：** JDK1.7 的 `ConcurrentHashMap` 底层采用 **分段的数组+链表**(`Segment` 数组结构（16）和 `HashEntry` 数组结构+链表数据结构) 实现，JDK1.8 采用的数据结构跟 `HashMap1.8` 的结构一样，数组+链表/红黑二叉树。`Hashtable` 和 JDK1.8 之前的 `HashMap` 的底层数据结构类似都是采用 **数组+链表** 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；

**实现线程安全的方式（重要）**:

- 在 JDK1.7 的时候，`ConcurrentHashMap` 对整个桶数组进行了分割分段(`Segment`，分段锁)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。

- 到了 JDK1.8 的时候，`ConcurrentHashMap` 已经摒弃了 `Segment` 的概念，而是直接用 `Node` 数组+链表+红黑树的数据结构来实现，并发控制使用 `synchronized` 和 CAS 来操作。（JDK1.6 以后 `synchronized` 锁做了很多优化） 整个看起来就像是优化过且线程安全的 `HashMap`，虽然在 JDK1.8 中还能看到 `Segment` 的数据结构，但是已经简化了属性，只是为了兼容旧版本；
- **`Hashtable`(同一把锁)** :使用 `synchronized` 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。

**Java 8 几乎完全重写了 `ConcurrentHashMap`**，代码量从原来 Java 7 中的 1000 多行，变成了现在的 6000 多行。

`ConcurrentHashMap` 取消了 `Segment` 分段锁，采用 `Node + CAS + synchronized` 来保证并发安全。数据结构跟 `HashMap` 1.8 的结构类似，数组+链表/红黑二叉树。**Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）**。

**Java 8 中，锁粒度更细，`synchronized` 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升。**

## 2、LinkedList为什么不能实现RandomAccess接口？

RandomAccess 是一个标记接口，用来表明实现该接口的类支持随机访问（即可以通过索引快速访问元素）。由于 LinkedList 底层数据结构是链表，内存地址不连续，只能通过指针来定位，不支持随机快速访问，所以不能实现 RandomAccess 接口。

## 3、ArrayList与LinkedList区别？

是否保证**线程安全**： ArrayList 和 LinkedList 都是不同步的，也就是**不保证线程安全**；
		底层**数据结构**： ArrayList 底层使用的是 Object 数组；LinkedList 底层使用的是 双向链表 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别）
		插入和删除是否受**元素位置**的影响：ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行add(E e)方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element)），时间复杂度就为 O(n)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。
LinkedList 采用链表存储，所以在头尾插入或者删除元素不受元素位置的影响（add(E e)、addFirst(E e)、addLast(E e)、removeFirst()、 removeLast()），时间复杂度为 O(1)，如果是要在指定位置 i 插入和删除元素的话（add(int index, E element)，remove(Object o),remove(int index)）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入和删除。
	是否支持**快速随机访问**： LinkedList 不支持高效的随机元素访问，而 ArrayList（实现了 RandomAccess 接口） 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。
	**内存空间占用**： ArrayList 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。

## 4、ArrayList的扩容机制

以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 **10**

如果ArrayList的当前大小不足以容纳新的元素，那么ArrayList就需要进行扩容操作。 在扩容操作中，ArrayList会创建一个新的数组，新数组的大小是原数组大小的1.5倍（也就是原数组大小+原数组大小的一半）。 这个1.5倍的值是在JDK的源码中定义的。 然后，ArrayList会使用 **System.arraycopy** 方法，将原有数组中的所有元素复制到新的数组中。

ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！ 奇偶不同，比如：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数.



## 5、Comparable 和 Comparator 的区别

Comparable 接口和 Comparator 接口都是 Java 中用于排序的接口，它们在实现类对象之间比较大小、排序等方面发挥了重要作用：

- Comparable 接口实际上是出自java.lang包 它有一个 compareTo(Object obj)方法用来排序
- Comparator接口实际上是出自 java.util 包它有一个compare(Object obj1, Object obj2)方法用来排序

- Comparable接口将比较代码嵌入需要进行比较的类的自身代码中，而Comparator接口在一个独立的类中实现比较。


- Comparable接口强制进行自然排序，而Comparator接口不强制进行自然排序，可以指定排序顺序

## 6、无序性和不可重复性的含义是什么

- 无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据**数据的哈希值**决定的。
- 不可重复性是指添加的元素按照 **equals()** 判断时 ，返回 false，需要同时重写 **equals()** 方法和 **hashCode()** 方法



## 7、比较HashSet、LinkedHashSet和TreeSet三者的异同

HashSet、LinkedHashSet 和 TreeSet 都是 Set 接口的实现类，都能保证元素唯一，并且都**不是线程安全**的。

HashSet、LinkedHashSet 和 TreeSet 的主要区别在于**底层数据结构**不同。HashSet 的底层数据结构是哈希表（基于 HashMap 实现）。LinkedHashSet 的底层数据结构是**链表和哈希表**，元素的插入和取出顺序满足 FIFO。TreeSet 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。

底层数据结构不同又导致这三者的**应用场景**不同。HashSet 用于不需要保证元素插入和取出顺序的场景，LinkedHashSet 用于保证元素的插入和取出顺序满足 FIFO 的场景，TreeSet 用于支持对元素自定义排序规则的场景。

HahSet集合的底层是哈希表，哈希表在JDK1.8之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。
JDK1.8引入红黑树大程度优化了HashMap的性能，那么对于我们来讲保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须重写hashCode和equals方法建立属于当前对象的比较方式。

## 8、Queue 与 Deque 的区别

Queue 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 先进先出（FIFO） 规则。


Deque 是双端队列，在队列的两端均可以插入或删除元素。Deque **扩展**了 Queue 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：
		

|  Queue 接口  | 抛出异常  | 返回特殊值 |
| :----------: | :-------: | :--------: |
|   插入队尾   | add(E e)  | offer(E e) |
|   删除队首   | remove()  |   poll()   |
| 查询队首元素 | element() |   peek()   |

| `Deque` **接口** |   抛出异常    |   返回特殊值    |
| :--------------: | :-----------: | :-------------: |
|     插入队首     | addFirst(E e) | offerFirst(E e) |
|     插入队尾     | addLast(E e)  | offerLast(E e)  |
|     删除队首     | removeFirst() |   pollFirst()   |
|     删除队尾     | removeLast()  |   pollLast()    |
|   查询队首元素   |  getFirst()   |   peekFist()    |
|   查询队尾元素   |   getLast()   |   peekLast()    |

## 9、<font color=red>ArrayDeque 与 LinkedList(模拟栈、队列) 的区别</font>

- ArrayDeque 是基于**可变长的数组和双指针**来实现，而 LinkedList 则通过链表来实现。


- ArrayDeque 不支持存储**NULL 数据**，但 LinkedList 支持。


ArrayDeque 是在 JDK1.6 才被引入的，而LinkedList 早在 JDK1.2 时就已经存在。

- ArrayDeque 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 LinkedList 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。


从性能的角度上，选用 ArrayDeque 来实现队列要比 LinkedList 更好。此外，ArrayDeque 也可以用于实现栈。

##10、PriorityQueue（初始容量（11））

- PriorityQueue 利用了二叉堆的数据结构来实现的，底层使用**可变长的数组**来存储数据
- PriorityQueue 通过堆元素的上浮和下沉，实现了在**O(logn)**的时间复杂度内插入元素和删除堆顶元素。
- PriorityQueue 是**非线程安全**的，且不支持存储 NULL 和 non-comparable 的对象。
- PriorityQueue 默认是**小顶堆**，但可以接收一个 Comparator 作为构造参数，从而来自定义元素优先级的先后。

PriorityQueue 在面试中可能更多的会出现在手撕算法的时候，典型例题包括**堆排序、求第 K 大的数、带权图的遍历**等，所以需要会熟练使用才行。

~~~java
//大顶堆
Queue<Integer>A=new PriorityQueue<>()
A=new PriorityQueue<>(new Comparator<Integer>() {

			@Override
			public int compare(Integer o1, Integer o2) {
				// TODO 自动生成的方法存根
				return o2-o1;
			}
});
//jdk8新特性：lambda表达式
B=new PriorityQueue<>((x,y) -> (y-x));
~~~

## 11、阻塞队列（BlockingQueue (阻塞队列)是一个接口，继承自 Queue）

BlockingQueue阻塞的原因是其支持**当队列没有元素时一直阻塞，直到有元素**；还支持**如果队列已满，一直等到队列可以放入新元素时再放入**。

BlockingQueue 常用于**生产者-消费者模型**中，生产者线程会向队列中添加数据，而消费者线程会从队列中取出数据进行处理。

阻塞队列实现类：ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue、SynchronousQueue、DelayQueue....

- ArrayBlockingQueue 和 LinkedBlockingQueue 是 Java 并发包中常用的两种阻塞队列实现，它们都是**线程安全**的。区别：
  - 底层实现：ArrayBlockingQueue 基于数组实现，而 LinkedBlockingQueue 基于链表实现。
  - 是否有界：ArrayBlockingQueue 是有界队列，必须在创建时指定容量大小。LinkedBlockingQueue 创建时可以不指定容量大小，默认是Integer.MAX_VALUE，也就是无界的。但也可以指定队列大小，从而成为有界的。
  - 锁是否分离： ArrayBlockingQueue中的锁是没有分离的，即生产和消费用的是同一个锁；LinkedBlockingQueue中的锁是分离的，即生产用的是putLock，消费是takeLock，这样可以防止生产者和消费者线程之间的锁争夺
  - 内存占用：ArrayBlockingQueue 需要提前分配数组内存，而 LinkedBlockingQueue 则是动态分配链表节点内存。这意味着，ArrayBlockingQueue 在创建时就会占用一定的内存空间，且往往申请的内存比实际所用的内存更大，而LinkedBlockingQueue 则是根据元素的增加而逐渐占用内存空间。

## 12、原生的线程安全的集合类

Vector，Stack，**HashTable**，**Enumeration**		------喂! SHE!

Concurrent为前缀的所有集合类：ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet、ConcurrentLinkedQueue、ConcurrentLinkedDeque......

## 13、<font color=red>HashMap</font> 和 Hashtable 的区别

- **线程是否安全**：

- **效率**：

- **对 Null key 和 Null value 的支持：**`HashMap` 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；

- **初始容量大小和每次扩充容量大小的不同**： ① 创建时如果不指定容量初始值，`Hashtable` 默认的初始大小为 11，之后每次扩充，容量变为原来的 **2n+1**。`HashMap` 默认的初始化大小为 **16**。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 `Hashtable` **会直接使用你给定的大小**，而 `HashMap` 会将其扩充为 2 的幂次方大小（`HashMap` 中的`tableSizeFor()`方法保证）。也就是说 `HashMap` 总是使用 2 的幂作为哈希表的大小。

- 负载因子 = (哈希表中的元素数量) / (哈希表的大小)，HashMap负载因子是0.75（泊松分布）---->扩容

- **底层数据结构：** JDK1.8 以后的 `HashMap` 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 **8**）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间（后文中我会结合源码对这一过程进行分析）。`Hashtable` 没有这样的机制。

  HashMap的put方法。

- ![image-20240521083111049](Redis.assets/image-20240521083111049.png)

## 14、HashMap和HashSet区别

- **实现接口**

- **存储值**

- **根据（key/对象）计算哈希值**

- **put/add**

  

## 15、HashMap和TreeMap区别

**综上，相比于`HashMap`来说 `TreeMap` 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力**

##16、HashMap 的底层实现

JDK1.8之前，**数组和链表**

JDK1.8之后，数组和链表/红黑树，链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。

## 17、HashMap多线程操作导致死循环问题

JDK1.7 头插法会导致环形链表

JDK1.8 尾插解决

![image-20240521084214901](Redis.assets/image-20240521084214901.png)

## 18、HashMap 的长度为什么是 2 的幂次方

- 为了**加快哈希计算**以及**减少哈希冲突**

解释：（n-1）&hash==hash%n；hash值就是要用低位的信息，那么结合&操作，&的另一个数最好低位全是1，这样&才有意义，否则结果就肯定是0那么&就没有意义，所以需要2^n

![image-20240521083455565](Redis.assets/image-20240521083455565.png)

## 19、HashMap为什么线程不安全？

JDK1.7 及之前版本，在多线程环境下，**`HashMap` 扩容时会造成死循环和数据丢失**的问题。

数据丢失这个在 JDK1.7 和 JDK 1.8 中都存在，这里以 JDK 1.8 为例进行介绍。

JDK 1.8 后，在 `HashMap` 中，多个键值对可能会被分配到同一个桶（bucket），并以链表或红黑树的形式存储。多个线程对 `HashMap` 的 `put` 操作会导致线程不安全，具体来说会有**数据覆盖**的风险

![image-20240521083406922](Redis.assets/image-20240521083406922.png

## 20、HashMap 常见的遍历方式?

**存在阻塞时 parallelStream 性能最高, 非阻塞时 parallelStream 性能最低** 。

## 21、ConcurrentHashMap为什么key和value不能为null？

`ConcurrentHashMap` 的 key 和 value 不能为 null 主要是**为了避免二义性**。null 是一个特殊的值，表示没有对象或没有引用。如果你用 null 作为键，那么你就无法区分这个键是否存在于 `ConcurrentHashMap` 中，还是根本没有这个键。同样，如果你用 null 作为值，那么你就无法区分这个值是否是真正存储在 `ConcurrentHashMap` 中的，还是因为找不到对应的键而返回的。

拿 get 方法取值来说，返回的结果为 null 存在两种情况：

- 值没有在集合中 ；
- 值本身就是 null。

这也就是二义性的由来。

多线程环境下，存在一个线程操作该 `ConcurrentHashMap` 时，其他的线程将该 `ConcurrentHashMap` 修改的情况，所以无法通过 `containsKey(key)` 来判断否存在这个键值对，也就没办法解决二义性问题了。

与此形成对比的是，`HashMap` 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个。如果**传入 null 作为参数，就会返回 hash 值为 0 的位置**的值。单线程环境下，不存在一个线程操作该 HashMap 时，其他的线程将该 `HashMap` 修改的情况，所以可以通过 `contains(key)`来做判断是否存在这个键值对，从而做相应的处理，也就不存在二义性问题。

也就是说，**多线程下无法正确判定键值对是否存在（存在其他线程修改的情况）**，单线程是可以的（不存在其他线程修改的情况）。

如果你确实需要在 ConcurrentHashMap 中使用 null 的话，可以使用一个**特殊的静态空对象来**代替 null。

~~~java
public static final Object NULL = new Object();
~~~

## 22、ConcurrentHashMap能保证复合操作的原子性吗？

**`ConcurrentHashMap` 是线程安全的，意味着它可以保证多个线程同时对它进行读写操作时，不会出现数据不一致的情况**，也不会导致 JDK1.7 及之前版本的 `HashMap` 多线程操作导致死循环问题。**但是，这并不意味着它可以保证所有的复合操作都是原子性的，一定不要搞混了！**

复合操作是指由多个基本操作(如`put`、`get`、`remove`、`containsKey`等)组成的操作，例如先判断某个键是否存在`containsKey(key)`，然后根据结果进行插入或更新`put(key, value)`。这种操作在执行过程中可能会被其他线程打断，导致结果不符合预期。

`ConcurrentHashMap` 提供了一些原子性的复合操作，如 `putIfAbsent`、`compute`、`computeIfAbsent` 、`computeIfPresent`、`merge`等。这些方法都可以接受一个函数作为参数，根据给定的 key 和 value 来计算一个新的 value，并且将其更新到 map 中。



## 23、拓展

### 1）Collection工具类

**`Collections` 工具类常用方法**:

- 排序
- 查找,替换操作
- 同步控制(不推荐，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合)****

#### 排序操作

~~~Java
void reverse(List list)//反转
void shuffle(List list)//随机排序
void sort(List list)//按自然排序的升序排序
void sort(List list, Comparator c)//定制排序，由Comparator控制排序逻辑
void swap(List list, int i , int j)//交换两个索引位置的元素
void rotate(List list, int distance)//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面

~~~

#### 查找，替换操作

~~~Java
int binarySearch(List list, Object key)//对List进行二分查找，返回索引，注意List必须是有序的
int max(Collection coll)//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)
int max(Collection coll, Comparator c)//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)
void fill(List list, Object obj)//用指定的元素代替指定list中的所有元素
int frequency(Collection c, Object o)//统计元素出现次数
int indexOfSubList(List list, List target)//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target)
boolean replaceAll(List list, Object oldVal, Object newVal)//用新元素替换旧元素

~~~



#### 同步控制（不重要）

`Collections` 提供了多个`synchronizedXxx()`方法·，该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。

我们知道 `HashSet`，`TreeSet`，`ArrayList`,`LinkedList`,`HashMap`,`TreeMap` 都是线程不安全的。`Collections` 提供了多个静态方法可以把他们包装成线程同步的集合。

~~~Java
synchronizedCollection(Collection<T>  c) //返回指定 collection 支持的同步（线程安全的）collection。
synchronizedList(List<T> list)//返回指定列表支持的同步（线程安全的）List。
synchronizedMap(Map<K,V> m) //返回由指定映射支持的同步（线程安全的）Map。
synchronizedSet(Set<T> s) //返回指定 set 支持的同步（线程安全的）set。

~~~

###2）希尔排序、堆排序、归并排序、快速排序、桶排序、基数排序、外部排序

```Java
//快速排序
class QuickSort{
    public void quickSort(int[] arr, int left, int right) {
        if (left < right) {
            // 找到基准值的位置
            int pivotIndex = partition(arr, left, right);
            // 对基准值左侧的数组进行快速排序
            quickSort(arr, left, pivotIndex - 1);
            // 对基准值右侧的数组进行快速排序
            quickSort(arr, pivotIndex + 1, right);
        }
    }

    private int partition(int[] arr, int left, int right) {
        // 选择最后一个元素作为基准值
        int pivot = arr[right];
        // i是小于基准值的元素的最后一个位置
        int i = left - 1;
        for (int j = left; j < right; j++) {
            // 如果当前元素小于或等于基准值，就交换到前面去
            if (arr[j] <= pivot) {
                i++;
                swap(arr, i, j);
            }
        }
        // 将基准值交换到正确的位置
        swap(arr, i + 1, right);
        // 返回基准值的位置
        return i + 1;
    }

    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

```Java
//桶排序----->>>>>应用：基数排序，计数排序
class BucketSort {
    public void bucketSort(int[] arr) {
        // 1. 找到最大值和最小值
        int max = arr[0];
        int min = arr[0];
        for (int num : arr) {
            if (num > max) {
                max = num;
            }
            if (num < min) {
                min = num;
            }
        }
        // 2. 确定桶的数量，这里假设桶的数量为10
        int bucketCount = 10;
        List<List<Integer>> buckets = new ArrayList<>();
        for (int i = 0; i < bucketCount; i++) {
            buckets.add(new ArrayList<>());
        }
        // 3. 将每个元素分配到桶中
        for (int num : arr) {
            int index = (num - min) / (max - min + 1) * (bucketCount - 1);
            buckets.get(index).add(num);
        }
        // 4. 对每个桶进行排序
        for (List<Integer> bucket : buckets) {
            Collections.sort(bucket);
        }
        // 5. 合并桶中的数据
        int index = 0;
        for (List<Integer> bucket : buckets) {
            for (int num : bucket) {
                arr[index++] = num;
            }
        }
    }
}
```

```java
//基数排序
class RadixSort {
    void radixSort(int[] arr) {
        // 1. 找到最大值，确定最大位数
        int max = arr[0];
        for (int num : arr) {
            if (num > max) {
                max = num;
            }
        }
        int maxDigits = 0;
        while (max != 0) {
            max /= 10;
            maxDigits++;
        }

        // 2. 初始化10个桶
        List<List<Integer>> buckets = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            buckets.add(new ArrayList<>());
        }

        // 3. 根据每个位上的数字进行排序
        for (int digit = 0; digit < maxDigits; digit++) {
            for (int num : arr) {
                // 计算当前位的数字
                int currentDigit = (num / (int) Math.pow(10, digit)) % 10;
                buckets.get(currentDigit).add(num);
            }

            // 将桶中的数据重新收集到原数组中
            int index = 0;
            for (List<Integer> bucket : buckets) {
                for (int num : bucket) {
                    arr[index++] = num;
                }
                // 清空桶，为下一次排序做准备
                bucket.clear();
            }
        }
    }
}
```





# MySQL

## 1、什么是数据库事务？讲⼀下事务的 ACID 特性？

**数据库事务是指数据库管理系统（DBMS）中的⼀个操作序列，这些操作必须作为⼀个不可分割的单元执⾏，即要么全部执行成功，要么全部失败回滚。**

事务的 ACID 特性指四个关键特征：原⼦性（Atomicity）、⼀致性（Consistency）、隔离性（Isolation）和持久性（Durability）。 

  1. 原⼦性（Atomicity）：**事务是⼀个原⼦操作，要么全部提交，要么全部回滚。**当⼀个事务执⾏期间发⽣故障，操作系统会⾃动将其回滚到事务执⾏之前的状态，保证数据的⼀致性。
  2. ⼀致性（Consistency）：**在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。**在事务执⾏期间，数据库中的数据可以处于中间状态，但在事务完成时必须保证数据的⼀致性。 
  3. 隔离性（Isolation）：**多个事务并发访问时，事务之间是隔离的，⼀个事务不应该影响其它事务运⾏效果。** **在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。**由并发事务所做的修改 必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另⼀事务修改它之前的状态，要么是另⼀事务修改它之后的状态，**事务不会查看到中间状态的数据。** 事务最复杂问题都是由事务隔离性引起的。完全的隔离性是不现实的，完全的隔离性要求数据库同⼀时间只执⾏⼀ 条事务，这样会严重影响性能。
  4. 持久性（Durability）：**⼀旦事务提交，其所做的修改必须永久保存到数据库中。**即使系统发⽣故障或宕机， 数据也能够保持不变。

有四种隔离级别： 

第⼀种隔离级别：**Read uncommitted(读未提交) **解决了更新丢失，但还是可能会出现脏读 

第⼆种隔离级别：**Read committed(读提交)** 解决了更新丢失和脏读问题 

第三种隔离级别：**Repeatable read(可重复读取) **解决了更新丢失、脏读、不可重复读、但是还会出现幻读 

第四种隔离级别：**Serializable(可序化)**解决了更新丢失、脏读、不可重复读、幻读(虚读)

------

转[7](##7、MySQL ⽇志有了解过吗？binlog、redolog、undolog 分别有什么作 ⽤、有什么区别？)和[8](##8、MVCC 是什么？InnoDB 是如何实现 MVCC 机制的？)

**在MySQL  InnoDB存储引擎下，RC、RR基于MVCC（多版本并发控制）进行并发事务控制，MVCC是基于数据版本对并发事务进行访问。**

ReadView是什么?

**ReadView是“快照读”sql执行时MVCC提取数据的依据，快照读就是最普通的Select查询SQl语句，当前读指代执行下列语句时数据读取的方式：Insert、Update、Delete、Select...for update、Select...lock in share mode。需要注意的是，连续两个快照读中出现当前读不一定会出现幻读，得看当前读有没有覆盖到其他事务新增的数据，如果没的话，则不会出现幻读。**

Undolog版本链不是被立即删除，MySQL确保版本链数据不再被“引用”后再进行删除。



## 2、数据库索引是什么，有什么作⽤，什么场景适合使⽤索引？

**数据库索引是⼀种数据结构，⽤于提高数据库表的查询效率。** 索引可以帮助数据库快速定位和检索存储在表中的数据，从⽽加快数据查询的速度。在数据量⽐较⼤时，使⽤索引可以极⼤地提⾼数据检索的效率。

**索引的作用是通过构建⼀个额外的数据结构（B-tree、哈希表等）来加速数据的检索。**索引可以包含⼀个或多个列，可以使⽤单列索引、组合索引、全⽂索引等多种⽅式来创建。

适合使⽤索引的场景包括： 

- 频繁查询的列，如主键、外键等。

- 经常作为查询条件的列，如 **WHERE、ORDER BY、GROUP BY **等语句中的列。 

- 经常需要连接的列，如**多表联合查询时的列。 **

- 数据量较⼤的表，通过索引可以加快数据检索速度。

但是索引也有⼀些缺点，包括： 

- 占⽤额外的存储空间，增加了存储成本。

- 建⽴索引需要时间，增加了系统的开销。 

- 数据库的更新操作（增删改）会导致索引的重建，影响系统的性能。

**字段上有主键和unique的会自动添加索引对象**，在mysql当中，索引是一个单独的对象，不同的存储引擎以不同的形式存在，在MyISAM存储引擎中，索引存储在一个.myi文件中.在InnoDB存储引擎中索引存储在一个逻辑名称叫做表空间的当中。在内存(Memory)存储引擎当中索引被存储在内存当中。不管索引存储在哪里，索引在mysql当中都是一个树的形式存在。(自平衡二叉树:B-Tree)

## 3、MySQL 中的索引是怎么实现的？B+ 树是什么，B 树和 B+ 树的区别， 为什么 MySQL 要⽤ B+ 树？

MySQL 中的索引**是通过 B+ 树**实现的。B+ 树是⼀种**多叉树**，它可以将数据按照⼀定的顺序组织起来，从⽽提⾼查询效率。 

**B+ 树与 B 树的区别在于**，

B+树 

- 叶⼦节点存数据 

B树 

- 所有节点都存数据

B+ 树的所有数据都存储在叶⼦节点上，⽽⾮叶⼦节点只存储索引，这样可以提⾼数据查询效率。

why choose B+ 

- INSERT / DELETE 

B树由于所有节点都保存所有数据，每当插⼊⼀条数据，哪怕是⾃增的，都可能造成整个树的**⾃旋重构**，当数据量很⼤的时候，这个时间成本和⻛险是巨⼤的 

B+树使⽤叶⼦节点保存数据，插⼊⼀条数据只会在叶⼦节点上插⼊，⼀般不会影响树的结构 

- SELECT 

B+树⽀持**范围查找，同时查询更高效** 

why ？因为叶⼦节点中，⻚与⻚之间是双向链表，⽽簇于簇之间有单向指针连接。

在 MySQL 中，B+ 树的实现主要是通过 InnoDB 存储引擎来实现的。InnoDB 存储引擎中的索引主要有**聚簇索引和 辅助索引**两种类型，聚簇索引是根据主键创建的索引，⽽辅助索引是根据⾮主键列创建的索引。

- 索引失效
  1. **模糊查询**索引会失效
  2. 使用**or**（or两边都有索引才会走索引，减少使用or）
  3.  **复合索引**（不使用左边的列，不走索引）
  4. 索引列参加**数学运算**/索引使用函数

## 4、MySQL ⽀持哪些存储引擎？默认使⽤哪个？MyISAM 和 InnoDB 引擎有什么区别，如何选择？

MySQL ⽀持多种存储引擎，包括 InnoDB、MyISAM、MEMORY、CSV 等。默认情况下，MySQL 使⽤的存储引擎是 InnoDB。

其中最常⽤的是 **InnoDB 和 MyISAM**，他们有以下区别： 

- InnoDB ⽀持**事务操作**，⽽ MyISAM 不⽀持事务 

- InnoDB ⽀持**外键**，⽽ MyISAM 不⽀持外键 

- InnoDB ⽀持**行级锁，表级锁**，⽽ MyISAM 只⽀持表级锁 

- InnoDB ⽀持**数据库异常崩溃后的安全恢复**（redo log），⽽ MyISAM 不⽀持 

- InnoDB 性能⽐MyISAM 更强，不管是在读写混合模式下还是只读模式下，随着 CPU 核数的增加，InnoDB 的**读写能力呈线性增⻓**。MyISAM 因为读写不能并发，它的处理能⼒跟核数没关系。
- InnoDB 和 MyISAM 实现索引都是使⽤ B+ 树，但实现⽅式不同（需要深入了解，否则不要回答）

如何选择？

- 在读密集的情况下，如果你不需要事务，也不需要保证数据库的崩溃回复，可以选择 MyISAM 其他时候⼤可放心使⽤ InnoDB

## 5、意向锁是什么？有什么作⽤？它是表级锁还是⾏级锁？

**表级锁**： 每次操作锁住整张表。开销小，加锁快；不会出现死锁；锁定粒度大，发生**锁冲突的概率最高**，并发度最低；

**行级锁**： 每次操作锁住一行数据。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高；

**MyISAM和MEMORY存储引擎**采用的是表级锁（table-level locking）；**InnoDB存储引擎**既支持行级锁（ row-level locking），也支持表级锁，但默认情况下是采用行级锁。

**不加索引情况下，update语句是表锁 ，加索引的情况下，update语句是行锁。**普通的 select 是不会加⾏级锁的，普通的 select 语句是利⽤ MVCC 实现⼀致性读，是⽆锁的。注意，加索引的情况下，不一定走的是行锁，索引也有失效的时候。很多时候即使用了索引也有可能会走全表扫描，这是因为 MySQL 优化器的原因。

常见的各种锁：

- 悲观锁

  悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，在获取数据的时候先加锁，确保数据的安全性。
  锁实现：关键字synchronized、Lock接口的实现
  使用场景：写操作比较多，先加锁可以保证写操作时数据正确

  传统的关系型数据库使用这种锁机制，比如行锁、表锁、读锁、写锁等，都是在操作之前先上锁

- 乐观锁

乐观锁认为自己在使用数据的时候不会被别的线程修改，所以不会添加锁，只是在更新的时候去判断之前有没有别的线程更改过这个数据
		锁实现：CAS算法，例如**AtomicInteger类的原子自增底层**是通过CAS实现的
		使用场景：读多，不加锁的特点能够使读的性能大幅度提升

- 读锁（共享锁）

事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。

场景：用于不更改或不更新数据的操作（只读操作），如 SELECT 语句。

- 写锁（排他锁）

事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。

场景：用于数据修改操作，例如 INSERT、UPDATE 或 DELETE。确保不会同时同一资源进行多重更新。

- 页锁

页锁即对组加锁，对相邻数据加锁，数据库中介于表锁和行锁之间的锁，开销和加锁速度介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般
		实现：BDB（存储引擎）

- 互斥锁（重量级锁或阻塞同步、悲观锁）

互斥锁是一个互斥的同步对象，意味着同一时间有且仅有一个线程可以获取它，互斥锁可适用于**一个共享资源每次只能被一个线程**访问的情况

- 自旋锁（CAS）

自旋锁在申请资源但是申请不到的情况下并不会挂起，而是会选择持续申请。这种锁结果适用于**每个线程占用较少时间**的锁，并且线程阻塞状态切换的代价远高于等待的代价时使用。

- 分布式锁

在很多场景中，我们为了保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等。有的时候，我们需要保证一个方法在同一时间内只能被同一个线程执行。

实现：**数据库实现分布式锁； 缓存（Redis等）实现分布式锁； Zookeeper实现分布式锁；**

- 区间锁（分段锁）

**ConcurrentHashMap **jdk1.7使用了分段锁来保证线程安全，效率比起使用**synchronized的HashTable**要高的很多。每个集合都可以看作是一个存储东西的房子，HashTable与ConcurrentHashMap存储的都是HashEntry数组（每个数组里面是链表，暂且忽略，知道就好）

本题回答：

**意向锁是什么：**

在使⽤ InnoDB 引擎的表⾥时对某些记录加上「共享锁」之前，需要先在表级别加上⼀个「意向共享锁」 

在使⽤ InnoDB 引擎的表⾥时对某些记录加上「独占锁」之前，需要先在表级别加上⼀个「意向独占锁」 

也就是，当执⾏插⼊、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。

**作用：**

为了快速判断表⾥是否有记录被加锁，可以提⾼数据库并发性能，防⽌死锁的发⽣。它是表级锁，⽽不是⾏级锁。

表锁和⾏锁是满⾜**读读共享、读写互斥、写写互斥的**。

![image-20240313095020577](Redis.assets/image-20240313095020577.png)

 ## 6、InnoDB有哪几类行锁？

InnoDB 行锁是通过对索引数据页上的记录加锁实现的，MySQL InnoDB 支持三种行锁定方式：

**记录锁（Record Lock）**：也被称为记录锁，属于单个行记录上的锁。
		**间隙锁（Gap Lock）**：锁定一个范围，不包括记录本身。
		**临键锁（Next-Key Lock）**：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题（MySQL 事务部分提到过）。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。

**在 InnoDB 默认的隔离级别 REPEATABLE-READ 下，行锁默认使用的是 Next-Key Lock。但是，如果操作的索引是唯一索引或主键，InnoDB 会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围。**

## 7、MySQL 日志有了解过吗？binlog、redolog、undolog 分别有什么作用、有什么区别？

binlog：即**存档⽇志，是 Server 层⽣成的的⽇志，主要用于数据库之间的主从同步**； 

redolog：即**前滚⽇志，是 Innodb 存储引擎层的⽇志，是 Mysql 实现持久性的重要保证，主要⽤于事务回归**、数据库事故故障恢复； 		

uodolog：即**回滚⽇志，是 Innodb 存储引擎层的⽇志，是 Mysql 实现原子性的重要保证，主要⽤于**MVCC；

**⼀条记录的 uodolog 格式由 trx_ 事务 id + roll_pointer 指针串成⼀个链表，即版本链。此外在读提交和可重复读隔离级别中，它和快照 readView 实现了 MVCC。 **（⾸先当我们执⾏⼀条增删改 sql 语句（没⽤begin）时，mysql 会隐式开启事务执⾏该条语句，在执⾏完毕后  mysql 会⾃动提交事务，我们就能看⻅增删改的实际结果，但是如果在事务执⾏中，mysql 在没提交事务的时候崩溃了，那么数据有问题了，此时就需要回滚到事务之前的数据，它本质就是⽤于撤销回退的⽇志（ctrl+z），在事务没提交之前，mysql 会记录更新前的数据到 undolog 中，当事务回滚时，就利⽤ uodolog ⽇志进⾏回滚。）

然后是 **redolog**，是为了**防⽌机器故障导致数据丢失**的物理⽇志，它将**内存写入磁盘的随机读写方式转换成顺序读写的方式**写⼊磁盘。需要注意的是，**当需要数据恢复的时候才会进行此操作（先顺序IO再随机IO，只有随机IO出现问题时才会使用redolog进行数据恢复）**。           （不问不答）它和 uodolog 区别是：redolog 记录了 此次事务完成后的数据状态，记录的是更新之后的值；undolog 记录了此次事务开始前的数据状态，记录的是更新之前的值；它保证了数据的持久性。 

**binlog 是存档⽇志，在完成⼀条更新操作后，server 层会⽣成 binlog，等事务提交时，将此事务运⾏中产⽣的所有DDL记录通过追加写统⼀写⼊ binlog ⽇志⽂件，保存的是全量的⽇志**，⽤于备份恢复和主从复制。

![image-20240313092244490](Redis.assets/image-20240313092244490.png)

**两阶段提交保证两台机器之间的同步**

![image-20240313094402856](Redis.assets/image-20240313094402856.png)

![image-20240314102825513](Redis.assets/image-20240314102825513.png)

## 8、MVCC 是什么？InnoDB 是如何实现 MVCC 机制的？

MVCC（Multi-Version Concurrency Control）是**⼀种并发控制机制，它通过为每个读操作创建⼀个视图（readview）来实现读写分离，保证了多个事务同时读写同⼀个数据时的⼀致性和并发性**。 

InnoDB 是 MySQL 数据库中的⼀种存储引擎，它通过使⽤ **MVCC 实现了⾼度并发的事务处理**。 

MVCC 的具体实现，依赖于数据库记录中的**隐式字段、undolog ⽇志、readView**。 

在内部实现中，InnoDB 通过(数据⾏的 DB_TRX_ID(**最近更新的事务id) 和 Read View**) 来判断数据的可⻅性，如不可⻅，则通过**undolog 版本链中的 DB_ROLL_PTR(回滚指针) 找到数据的历史版本**。-------------------快照读 

每个事务读到的数据版本可能是不⼀样的，**在同⼀个事务中，⽤户只能看到该事务创建 Read View 之前已经提交的修改和该事务本身做的修改**

------

**拓展：**

**MVCC 是怎么解决不可重复读的 **

**在 RC 读已提交下, 在事务中每⼀次执⾏快照读时⽣成 ReadView, 这也就造成了每次读取就有不同 ReadView, 那么 就会读到已提交的事务修改的内容, 造成不可重复读的问题。**

**解决 RR 不可重复读主要靠 readview, 在隔离级别为可重复读时, 仅在事务中第⼀次执⾏快照读时⽣成 ReadView,  后续复⽤该 ReadView**。 由于后续**复⽤了 ReadView, 所以数据对当前事务的可⻅性和第⼀次是⼀样的**, 一般来说从 undolog 中读到的数据快照 和第⼀次是⼀样的, 但是需要注意在两次快照读中间出现当前读的情况，若当前读覆盖了其他事务新增的数据，则会重新生成readview，出现幻读的现象。

**MVCC是怎么防⽌幻读的 **

**InnoDB 存储引擎在 RR 级别下通过 MVCC 和 Next-key Lock(临键锁) 来解决幻读问题 **。

1、执⾏普通 select，此时会以 MVCC 快照读的⽅式读取数据 

- 快照读: **避免加锁通过 MVCC 来进⾏控制, 使其他事务所做的更新对当前事务不可⻅, 从⽽防⽌幻读**. 

在快照读的情况下，RR 隔离级别只会在事务开启后的第⼀次查询⽣成 Read View ，并使⽤⾄事务提交。所以在⽣成 Read View 之后其它事务所做的更新、插⼊记录版本对当前事务并不可⻅，实现了可重复读和防⽌快照读下的  “幻读” 

2、执⾏ select...for update/lock in share mode、insert、update、delete 等当前读 

- 当前读: **通过临键锁 next-key-lock 锁住空隙, 防⽌其他事务在查询的范围内插⼊数据, 从⽽防⽌幻读. **

在当前读下，读取的都是最新的数据，如果其它事务有插⼊新的记录，并且刚好在当前事务查询范围内，就会产⽣幻读！InnoDB 使⽤ **Next-key Lock 临键锁**来防⽌这种情况。当执⾏当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防⽌其它事务在查询范围内插⼊数据。**只要我不让你插⼊，就不会发⽣幻读**

## 9、覆盖索引和联合索引是什么？讲⼀下索引的最左前缀匹配原则。

对于Innodb来讲，主键索引（聚簇索引）一定是存在的。

**覆盖索引** 

**一个索引包含了（或覆盖了）满足查询结果的数据**就叫做覆盖索引。

是指**SQL 中 query 的所有字段，在索引 B+ Tree 的叶⼦节点上都能找得到的那些索引，从$\textcolor{red}{⼆级索引（普通索引）}$中查询得到记录**，⽽不需要通过**聚簇索引**查询获得，可以$\textcolor{red}{避免回表}$的操作

**联合索引**

通过将**多个字段组合成⼀个索引**，该索引就被称为联合索引

**最左前缀匹配原则**

使⽤**联合索引时，存在最左匹配原则，也就是按照最左优先的⽅式进⾏索引的匹配。在使⽤联合索引进⾏查询的时候，如果不遵循「最左匹配原则**，联合索引会失效，这样就⽆法利⽤到索引快速查询的特性了

综上所示，联合索引的最左匹配原则，在遇到**范围查询**（如 >、<）的时候，就会停⽌匹配，也就是范围查询的字段可以⽤到联合索引，但是在范围查询字段的后⾯的字段⽆法⽤到联合索引。注意，对于 **>=、<=、BETWEEN、 like 前缀匹配的范围查询**，并不会停⽌匹配。

![image-20240315101935578](Redis.assets/image-20240315101935578.png)







# SSM--->Spring、SpringMVC、MyBatis    + SpringBoot

## Spring 

Spring 各个模块的依赖关系：

![](https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/20200902100038.png)

- **spring-core**：Spring 框架基本的核心工具类。

- **spring-beans**：提供对 bean 的创建、配置和管理等功能的支持。

- <font color=red>**spring-context**:</font>提供对**国际化、事件传播、资源加载**等功能的支持。**

  `spring-context`是一个核心模块，它提供了Spring应用程序上下文（Application Context）的功能。**这个模块定义了Spring的IoC（控制反转）容器**，**并提供了与Spring应用程序上下文相关的服务。**



- **spring-expression**：提供对表达式语言（Spring Expression Language） SpEL 的支持，只依赖于 core 模块，不依赖于其他模块，可以单独使用

  AOP：

- **spring-aspects**：该模块为与 AspectJ 的集成提供支持。

- **spring-aop**：提供了面向切面的编程实现。

- **spring-instrument**：提供了为 JVM 添加代理（agent）的功能。 具体来讲，它为 Tomcat 提供了一个织入代理，能够为 Tomcat 传递类文 件，就像这些文件是被类加载器加载的一样。没有理解也没关系，这个模块的使用场景非常有限

​		Data Access/Integration：

- **spring-jdbc**：提供了对数据库访问的抽象 JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java 程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。

- **spring-tx**：提供对事务的支持。

- **spring-orm**：提供对 Hibernate、JPA、iBatis 等 ORM 框架的支持。

- **spring-oxm**：提供一个抽象层支撑 OXM(Object-to-XML-Mapping)，例如：JAXB、Castor、XMLBeans、JiBX 和 XStream 等。

- **spring-jms** : 消息服务。自 Spring Framework 4.1 以后，它还提供了对 spring-messaging 模块的继承。

​		Spring Web：

- **spring-web**：对 Web 功能的实现提供一些最基础的支持。

- **spring-webmvc**：提供对 Spring MVC 的实现。

- **spring-websocket**：提供了对 WebSocket 的支持，WebSocket 可以让客户端和服务端进行双向通信。

- **spring-webflux**：提供对 WebFlux 的支持。WebFlux 是 Spring Framework 5.0 中引入的新的响应式框架。与 Spring MVC 不同，它不需要 Servlet API，是完全异步。

​		Messaging：

- **spring-messaging** 是从 Spring4.0 开始新加入的一个模块，主要职责是为 Spring 框架集成一些基础的报文传送应用。

​		Spring  Test:

- Spring 团队提倡测试驱动开发（TDD）。有了控制反转 (IoC)的帮助，单元测试和集成测试变得更简单。

- Spring 的测试模块对 JUnit（单元测试框架）、TestNG（类似 JUnit）、Mockito（主要用来 Mock 对象）、PowerMock（解决 Mockito 的问题比如无法模拟 final, static， private 方法）等等常用的测试框架支持的都比较好。

  ![](https://cdn.nlark.com/yuque/0/2022/png/21376908/1663726169861-b5acb757-17e0-4d3d-a811-400eb7edd1b3.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_29%2Ctext_5Yqo5Yqb6IqC54K5%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

  

**Spring,Spring MVC,Spring Boot 之间什么关系?**（总结的不好---后面要改）

- Spring MVC 是 Spring 中的一个很重要的模块，主要赋予 Spring 快速构建 MVC 架构的 Web 程序的能力。MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。


- 使用 Spring 进行开发各种配置过于麻烦比如开启某些 Spring 特性时，需要用 XML 或 Java 进行显式配置。于是，Spring Boot 诞生了！


1. Spring 旨在简化 J2EE 企业应用程序开发。Spring Boot 旨在简化 Spring 开发（减少配置文件，开箱即用！）。

2. Spring Boot 只是简化了配置，如果你需要构建 MVC 架构的 Web 程序，你还是需要使用 Spring MVC 作为 MVC 框架，只是说 Spring Boot 帮你简化了 Spring MVC 的很多配置，真正做到开箱即用！

   SpringBoot 是基于 **Spring 框架的⼀个开发框架**，⽤于快速构建独⽴的、⽣产级别的 Spring 应⽤程序。**它通过⾃动配置和约定优于配置的**⽅式，简化了 Spring 应⽤程序的配置和开发过程。SpringBoot 集成了很多常⽤ 的第三⽅库和⼯具，例如 Spring Data、Spring Security、Thymeleaf、Logback 等，可以极⼤地提⾼开发效 率。

   因此，SpringBoot 可以看作是在 Spring 的基础上，通过⾃动配置和约定优于配置的⽅式，提供了更加简单、快速 的开发体验。⽽ SpringMVC 则是 Spring 框架中⽤于构建 Web 应⽤程序的模块。

    Spring Boot 内置了 Tomcat、Undertow 等服务器，不⽤像传统 SSM ⼀样⾃⼰ 去搭 Tomcat 等环境了，简化了开发

------



依赖倒置原则(Dependence Inversion Principle)，简称DIP，主要倡导面向抽象编程，面向接口编程，不要面向具体编程，让**上层**不再依赖**下层**，下面改动了，上面的代码不会受到牵连。这样可以大大降低程序的耦合度，耦合度低了，扩展力就强了，同时代码复用性也会增强。（**软件七大开发原则都是在为解耦合服务**）

控制反转（Inversion of Control，缩写为IoC）

- 控制反转是一种思想。
- 控制反转是为了降低程序耦合度，提高程序扩展力，达到OCP原则，达到DIP原则。

- 控制反转的核心是：**将对象的创建权交出去，将对象和对象之间关系的管理权交出去，由第三方容器来负责创建与维护**。

- 控制反转常见的实现方式：依赖注入（Dependency Injection，简称DI）

通常，依赖注入的实现又包括两种方式（底层调用反射）：

- set方法注入（基于set方法实现的，底层会通过反射机制调用属性对应的set方法然后给属性赋值。这种方式要求属性必须对外提供set方法。）

- 构造方法注入（通过调用构造方法来给属性赋值。）

而Spring框架就是一个实现了IoC思想的框架。

- 在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。

### Spring Bean

#### 1）是什么

**Bean 代指的就是那些被 IoC 容器所管理的对象。**

我们需要告诉 IoC 容器帮助我们管理哪些对象，这个是通过配置元数据来定义的。配置元数据可以是 XML 文件、注解或者 Java 配置类。

声明Bean的注解：

- @Component：通用的注解，可标注任意类为 Spring 组件。如果一个 Bean 不知道属于哪个层，可以使用@Component 注解标注。
- @Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。
- @Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。
- @Controller : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面

#### 2）@Component 和 @Bean 的区别是什么？

-  `@Component`注解作用于类，而`@Bean`注解作用于方法。
- `@Component` 通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean,@Bean告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。
- @Bean 注解比 @Component 注解的自定义性更强，而且很多地方我们只能通过 @Bean 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 Spring容器时，则只能通过 @Bean来实现。

####3）@Autowired 和@Resource的区别是什么？

`@Autowired` 属于 **Spring 内置**的注解，默认的注入方式为byType（根据类型进行匹配），也就是说会优先根据接口类型去匹配并注入 Bean （接口的实现类）。

这会有什么问题呢？ 当一个接口存在多个实现类的话，byType这种方式就无法正确注入对象了，因为这个时候 Spring 会同时找到多个满足条件的选择，默认情况下它自己不知道选择哪一个。这种情况下，注入方式会变为 byName（根据名称进行匹配），这个名称通常就是类名（首字母小写）。

`@Resource`属于**JDK**提供的注解，默认注入方式为 byName。如果无法通过名称匹配到对应的 Bean 的话，注入方式会变为byType。

总结：

- @Autowired 是 Spring 提供的注解，@Resource 是 JDK 提供的注解。
- @Autowired 默认的注入方式为byType（根据类型进行匹配），@Resource默认注入方式为 byName（根据名称进行匹配）。
- 当一个接口存在多个实现类的情况下，@Autowired 和@Resource都需要通过名称才能正确匹配到对应的 Bean。**@Autowired 可以通过 @Qualifier 注解来显式指定名称，@Resource可以通过 name 属性来显式指定名称。**
- @Autowired 支持在**构造函数**、方法、字段和**参数**上使用。@Resource 主要用于字段和方法上的注入，不支持在构造函数或参数上使用。

#### 4）Bean的作用域是什么？

- singleton
  - Spring的IoC容器中，默认情况下，**Bean对象是单例的**。Bean对象的创建是在初始化Spring上下文的时候就完成的。

- prototype

  - 如果想让Spring的Bean对象以多例的形式存在，可以在bean标签中指定scope属性的值为：**prototype**，这样Spring会在**每一次执行getBean()方法的时候创建Bean对象**，调用几次则创建几次。

- 其它scope（共8个）
  - singleton：默认的，单例。
  - prototype：原型。每调用一次getBean()方法则获取一个新的Bean对象。或每次注入的时候都是新对象。
  - request：一个请求对应一个Bean。**仅限于在WEB应用中使用**。
  - session：一个会话对应一个Bean。**仅限于在WEB应用中使用**。
  - global session：**portlet应用中专用的**。如果在Servlet的WEB应用中使用global session的话，和session一个效果。（portlet和servlet都是规范。servlet运行在servlet容器中，例如Tomcat。portlet运行在portlet容器中。）
  - application：一个应用对应一个Bean。**仅限于在WEB应用中使用。**
  - websocket：一个websocket生命周期对应一个Bean。**仅限于在WEB应用中使用。**
  - 自定义scope：很少使用。

#### 5）bean是线程安全的吗?

Spring 框架中的 **Bean 是否线程安全**，取决于其**作用域和状态**。

我们这里以最常用的两种作用域 prototype 和 singleton 为例介绍。几乎所有场景的 Bean 作用域都是使用默认的 singleton ，重点关注 singleton 作用域即可。

**prototype 作用域下，每次获取都会创建一个新的 bean 实例，不存在资源竞争问题，所以不存在线程安全问题**。**singleton 作用域下，IoC 容器中只有唯一的 bean 实例，可能会存在资源竞争问题（取决于 Bean 是否有状态）。如果这个 bean 是有状态的话，那就存在线程安全问题（有状态 Bean 是指包含可变的成员变量的对象）。**

不过，大部分 Bean 实际都是无状态（没有定义可变的成员变量）的（比如 Dao、Service），这种情况下， Bean 是线程安全的。

对于有状态单例 Bean 的线程安全问题，常见的有两种解决办法：

- 在 Bean 中尽量**避免定义可变**的成员变量。
- 在类中定义一个 **ThreadLocal**成员变量，将需要的可变成员变量保存在 **ThreadLocal** 中（推荐的一种方式）。

####6）Bean的生命周期了解吗？（面试）

Spring其实就是一个管理Bean对象的工厂。它负责对象的创建，对象的销毁等。

所谓的生命周期就是：**对象从创建开始到最终销毁的整个过程。**

- 什么时候创建Bean对象？

- 创建Bean对象的前后会调用什么方法？

- Bean对象什么时候销毁？

- Bean对象的销毁前后调用什么方法？

------

答案：

Bean生命周期可以粗略的划分为五大步（**粗略版**）：

- 第一步：实例化Bean
- 第二步：Bean属性赋值
- 第三步：初始化Bean
- 第四步：使用Bean
- 第五步：销毁Bean

![](https://cdn.nlark.com/yuque/0/2022/png/21376908/1665388735200-444405f6-283d-4b3a-8cdf-8c3e01743618.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_24%2Ctext_5Yqo5Yqb6IqC54K5%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

注意：

- 第一：只有正常关闭spring容器，bean的销毁方法才会被调用。
- 第二：ClassPathXmlApplicationContext类才有close()方法。
- 第三：配置文件中的init-method指定初始化方法。destroy-method指定销毁方法

Bean生命周期之7步（**较详细版**）（一般回答这个即可）：

在以上的5步中，第3步是初始化Bean，如果你还想在初始化前和初始化后添加代码，可以加入“Bean后处理器”。编写一个类实现**BeanPostProcessor**类，并且重写before和after方法。

如果加上Bean后处理器的话，Bean的生命周期就是7步了：

![](https://cdn.nlark.com/yuque/0/2022/png/21376908/1665393936765-0ea5dcdd-859a-4ac5-9407-f06022c498b9.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_29%2Ctext_5Yqo5Yqb6IqC54K5%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

 Bean生命周期之10步（**详细版**）：

![](https://cdn.nlark.com/yuque/0/2022/png/21376908/1665394697870-15de433a-8d50-4b31-9b75-b2ca7090c1c6.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_12%2Ctext_5Yqo5Yqb6IqC54K5%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

Aware相关的接口包括：BeanNameAware、 、BeanFactoryAware

- 当Bean实现了BeanNameAware，Spring会将Bean的名字传递给Bean。
- 当Bean实现了BeanClassLoaderAware，Spring会将加载该Bean的类加载器传递给Bean。
- 当Bean实现了BeanFactoryAware，Spring会将Bean工厂对象传递给Bean。

####7）Bean的作用域不同，管理方式也不同

- 对于**singleton作用域的Bean**，Spring 能够精确地知道该Bean何时被创建，何时初始化完成，以及何时被销毁；
- 而对于 prototype 作用域的 Bean，Spring 只负责创建，当容器创建了 Bean 的实例后，Bean 的实例就交给客户端代码管理，Spring 容器将不再跟踪其生命周期。

#### 8）Bean的循环依赖问题

A对象中有B属性。B对象中有A属性。这就是循环依赖。我依赖你，你也依赖我。

比如：丈夫类Husband，妻子类Wife。Husband中有Wife的引用。Wife中有Husband的引用

![](https://cdn.nlark.com/yuque/0/2022/png/21376908/1665452274046-82594b87-2974-4e08-a6ab-2218d001d14f.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_16%2Ctext_5Yqo5Yqb6IqC54K5%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

- **在singleton + set注入的情况下，循环依赖是没有问题的。Spring可以解决这个问题。**

  - 构造注入是无法解决这种循环依赖的，因为构造方法注入会导致**实例化对象的过程**和**对象属性赋值的过程**没有分离开，必须在一起完成导致的。

  - 根本的原因在于：这种方式可以做到将“实例化Bean”和“给Bean属性赋值”这两个动作分开去完成。

    实例化Bean的时候：调用无参数构造方法来完成。**此时可以先不给属性赋值，可以提前将该Bean对象“曝光”给外界。**

  - **Spring只能解决setter方法注入的单例bean之间的循环依赖。ClassA依赖ClassB，ClassB又依赖ClassA，形成依赖闭环。Spring在创建ClassA对象后，不需要等给属性赋值，直接将其曝光到bean缓存当中。在解析ClassA的属性时，又发现依赖于ClassB，再次去获取ClassB，当解析ClassB的属性时，又发现需要ClassA的属性，但此时的ClassA已经被提前曝光加入了正在创建的bean的缓存中，则无需创建新的的ClassA的实例，直接从缓存中获取即可。从而解决循环依赖问题。**

- 当循环依赖的**所有Bean**的scope="prototype"的时候，产生的循环依赖，Spring是无法解决的，会出现**BeanCurrentlyInCreationException**异常。
- 如果其中一个是singleton，另一个是prototype，是没有问题的。

### <font color=red>Spring Aop,使用过吗？怎么使用？</font>

IoC使软件组件松耦合。AOP让你能够捕捉系统中经常使用的功能，把它转化成组件。

**AOP（Aspect Oriented Programming）**：面向切面编程，面向方面编程。（AOP是一种编程技术）

**AOP是对OOP的补充延伸。**

AOP底层使用的就是动态代理来实现的。

Spring的AOP使用的动态代理是：**JDK动态代理 + CGLIB动态代理技术**。Spring在这两种动态代理中灵活切换，如果是代理接口，会默认使用JDK动态代理，如果要代理某个类，这个类没有实现接口，就会切换使用CGLIB。当然，你也可以强制通过一些配置让Spring只使用CGLIB。

AOP(Aspect-Oriented Programming)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如**事务处理、日志管理、权限控制**等）封装起来，**便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性**。

Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 **JDK Proxy**，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 **Cglib** 生成一个被代理对象的子类来作为代理，如下图所示：

![](https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/230ae587a322d6e4d09510161987d346.jpeg)

当然你也可以使用 `AspectJ `！Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。

![image-20240307224632998](Redis.assets/image-20240307224632998.png)

Spring对AOP的实现包括以下3种方式：

- <font color=red>**第一种方式：Spring框架结合AspectJ框架实现的AOP，基于注解方式。**</font>
- <font color=red>**第二种方式：Spring框架结合AspectJ框架实现的AOP，基于XML方式。**</font>
- 第三种方式：Spring框架自己实现的AOP，基于XML配置方式。

实际开发中，都是Spring+AspectJ来实现AOP。所以我们重点学习第一种和第二种方式。

使用Spring AOP进行登录验证：

1. **定义登录验证逻辑**：首先，你需要定义一个登录验证的逻辑。这通常涉及用户名和密码的验证。

2. **创建拦截器**：创建一个拦截器类，实现`HandlerInterceptor`接口，或者继承`HandlerInterceptorAdapter`类。在这个拦截器中，你可以添加登录验证逻辑。

3. **配置拦截器**：在Spring配置文件中，或者使用Java配置，注册你的拦截器。你可以配置哪些URL需要拦截，哪些不需要。

4. **使用代理**：Spring AOP使用代理来拦截方法调用。如果你的目标对象没有实现任何接口，Spring会使用CGLIB来创建代理。如果你的目标对象实现了接口，Spring会使用JDK动态代理。

5. **配置AOP**：在Spring配置文件中，或者使用Java配置，配置AOP，包括切入点（Pointcut）和通知（Advice）。

   ![image-20240522211405218](Redis.assets/image-20240522211405218.png)

#### 1）Spring AOP和AspectJ AOP有什么区别？

**Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作**(Bytecode Manipulation)。

Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，

如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多。

#### 2）AspectJ定义的通知类型

- 前置通知：@Before 目标方法执行之前的通知
- 后置通知：@AfterReturning 目标方法执行之后的通知
- 异常通知：@AfterThrowing 发生异常之后执行的通知
- 最终通知：@After 放在finally语句块中的通知
- Around （环绕通知）：@Around 目标方法之前添加通知，同时目标方法执行之后添加通知。编程式控制目标对象的方法调用。环绕通知是**所有通知类型中可操作范围最大的一种**，因为它可以直接拿到目标对象，以及要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法。

#### 3）多个切面的执行顺序如何控制？

1、通常使用**@Order 注解直接定义切面顺序**

~~~java
// 值越小优先级越高
@Order(3)
@Component
@Aspect
public class LoggingAspect implements Ordered {

~~~

2、实现Ordered 接口重写 getOrder 方法。

~~~java
@Component
@Aspect
public class LoggingAspect implements Ordered {

    // ....

    @Override
    public int getOrder() {
        // 返回值越小优先级越高
        return 1;
    }
}

~~~

### Spring 事务

#### 1）Spring实现事务的两种方式

- 编程式事务
  - 通过编写代码的方式来实现事务的管理。通过 `TransactionTemplate`或者 `TransactionManager` 手动管理事务，事务范围过大会出现事务未提交导致超时，因此事务要比锁的粒度更小。
- 声明式事务
  - 基于注解方式
  - 基于XML配置方式

上面两种方式实际是通过 AOP 实现（基于`@Transactional` 的全注解方式使用最多）		

#### 2）事务属性

- 事务传播行为
- 事务隔离级别
- 事务超时
- 只读事务
- 设置出现哪些异常回滚事务
- 设置出现哪些异常不回滚事务

#### 3）Spring有哪几种事务传播行为

**事务传播行为是为了解决业务层方法之间互相调用的事务问题**。事务传播行为在spring框架中被定义为**枚举类型**。

当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。

**1.`TransactionDefinition.PROPAGATION_REQUIRED`**

使用的最多的一个事务传播行为，我们平时经常使用的`@Transactional`注解默认使用就是这个事务传播行为。//如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。

**`2.TransactionDefinition.PROPAGATION_REQUIRES_NEW`**

创建一个新的事务，如果当前存在事务，则把当前事务挂起。//也就是说不管外部方法是否开启事务，`Propagation.REQUIRES_NEW`修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。

**3.`TransactionDefinition.PROPAGATION_NESTED`**

如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于`TransactionDefinition.PROPAGATION_REQUIRED`。

**4.`TransactionDefinition.PROPAGATION_MANDATORY`**

如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）

这个使用的很少。

若是错误的配置以下 3 种事务传播行为，事务将不会发生回滚：

**`TransactionDefinition.PROPAGATION_SUPPORTS`**: 如果当前存在事务，则加入该事务；//如果当前没有事务，则以非事务的方式继续运行。

**`TransactionDefinition.PROPAGATION_NOT_SUPPORTED`**: //以非事务方式运行，//如果当前存在事务，则把当前事务挂起。

**`TransactionDefinition.PROPAGATION_NEVER`**: //以非事务方式运行，//如果当前存在事务，则抛出异常。

#### 4）隔离级别

**`TransactionDefinition.ISOLATION_DEFAULT`** :使用后端数据库默认的隔离级别，MySQL 默认采用的 `REPEATABLE_READ` 隔离级别 Oracle 默认采用的 `READ_COMMITTED` 隔离级别.

**`TransactionDefinition.ISOLATION_READ_UNCOMMITTED`** :最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**

**`TransactionDefinition.ISOLATION_READ_COMMITTED`** : 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**

**`TransactionDefinition.ISOLATION_REPEATABLE_READ`** : 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生。**

**`TransactionDefinition.ISOLATION_SERIALIZABLE`** : 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。但是这将严重影响程序的性能。通常情况下也不会用到该级别。

####5）@Transactional（rollbackFor=Exception.class）注解了解吗？

`Exception` 分为运行时异常 `RuntimeException` 和非运行时异常。事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。

当 `@Transactional` 注解作用于类上时，**该类的所有 public 方法将都具有该类型的事务属性**，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。

`@Transactional` 注解默认回滚策略是**只有在遇到`RuntimeException`(运行时异常) 或者 `Error` 时才会回滚事务，而不会回滚 `Checked Exception`（受检查异常）**。这是因为 Spring 认为`RuntimeException`和 Error 是不可预期的错误，而受检异常是可预期的错误，可以通过业务逻辑来处理。

如果想要修改默认的回滚策略，可以使用 `@Transactional` 注解的 `rollbackFor` 和 `noRollbackFor` 属性来指定哪些异常需要回滚，哪些异常不需要回滚。例如，如果想要让所有的异常都回滚事务，可以使用如下的注解：

~~~Java
@Transactional(rollbackFor = Exception.class)
public void someMethod() {
// some business logic
}
~~~

如果想要让某些特定的异常不回滚事务，可以使用如下的注解：

~~~Java
@Transactional(noRollbackFor = CustomException.class)
public void someMethod() {
// some business logic
}
~~~

![image-20240522212252002](Redis.assets/image-20240522212252002.png)





#### 6）Spring Data JPA（6，7没有接触过）

JPA 重要的是实战，这里仅对小部分知识点进行总结

##### 1）如何使用JPA在数据库中非持久化一个字段

假如我们有下面一个类：

~~~java
@Entity(name="USER")
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    @Column(name = "ID")
    private Long id;

    @Column(name="USER_NAME")
    private String userName;

    @Column(name="PASSWORD")
    private String password;

    private String secrect;

}

~~~

如果我们想让`secrect` 这个字段不被持久化，也就是不被数据库存储怎么办？我们可以采用下面几种方法：

~~~Java
static String transient1; // not persistent because of static
final String transient2 = "Satish"; // not persistent because of final
transient String transient3; // not persistent because of transient
@Transient
String transient4; // not persistent because of @Transient

~~~

一般使用后面两种方式比较多，我个人使用注解的方式比较多。

##### 2)JPA的审计功能是做什么的？有什么用？

审计功能主要是帮助我们记录数据库操作的具体行为比如某条记录是谁创建的、什么时间创建的、最后修改人是谁、最后修改时间是什么时候。

~~~Java
@Data
@AllArgsConstructor
@NoArgsConstructor
@MappedSuperclass
@EntityListeners(value = AuditingEntityListener.class)
public abstract class AbstractAuditBase {

    @CreatedDate
    @Column(updatable = false)
    @JsonIgnore
    private Instant createdAt;

    @LastModifiedDate
    @JsonIgnore
    private Instant updatedAt;

    @CreatedBy
    @Column(updatable = false)
    @JsonIgnore
    private String createdBy;

    @LastModifiedBy
    @JsonIgnore
    private String updatedBy;
}

~~~

`@CreatedDate`: 表示该字段为创建时间字段，在这个实体被 insert 的时候，会设置值

`@CreatedBy` :表示该字段为创建人，在这个实体被 insert 的时候，会设置值

`@LastModifiedDate`、`@LastModifiedBy`同理

##### 3）实体之间的关键关系注解有哪些？

- `@OneToOne` : 一对一。
- `@ManyToMany`：多对多。
- `@OneToMany` : 一对多。
- `@ManyToOne`：多对一。

利用 `@ManyToOne` 和 `@OneToMany` 也可以表达多对多的关联关系。

#### 7）Spring Security

Spring Security 重要的是实战，这里仅对小部分知识点进行总结。

##### 1）有哪些控制请求访问权限的方法？

`permitAll()`：无条件允许任何形式访问，不管你登录还是没有登录。

`anonymous()`：允许匿名访问，也就是没有登录才可以访问。

`denyAll()`：无条件决绝任何形式的访问。

`authenticated()`：只允许已认证的用户访问。

`fullyAuthenticated()`：只允许已经登录或者通过 remember-me 登录的用户访问。

`hasRole(String)` : 只允许指定的角色访问。

`hasAnyRole(String)` : 指定一个或者多个角色，满足其一的用户即可访问。

`hasAuthority(String)`：只允许具有指定权限的用户访问

`hasAnyAuthority(String)`：指定一个或者多个权限，满足其一的用户即可访问。

`hasIpAddress(String)` : 只允许指定 ip 的用户访问



##### 2）有哪些控制请求访问权限的方法？

[Spring Security 中的 hasRole 和 hasAuthority 有区别吗？](https://mp.weixin.qq.com/s/GTNOa2k9_n_H0w24upClRw)

##### 3）有哪些控制请求访问权限的方法？

如果我们需要保存密码这类敏感数据到数据库的话，需要先加密再保存。

Spring Security 提供了多种加密算法的实现，开箱即用，非常方便。这些加密算法实现类的父类是 `PasswordEncoder` ，如果你想要自己实现一个加密算法的话，也需要继承 `PasswordEncoder`。

`PasswordEncoder` 接口一共也就 3 个必须实现的方法。

~~~Java
public interface PasswordEncoder {
    // 加密也就是对原始密码进行编码
    String encode(CharSequence var1);
    // 比对原始密码和数据库中保存的密码
    boolean matches(CharSequence var1, String var2);
    // 判断加密密码是否需要再次进行加密，默认返回 false
    default boolean upgradeEncoding(String encodedPassword) {
        return false;
    }
}

~~~

##### 4)如何优雅更换系统使用的加密算法

如果我们在开发过程中，突然发现现有的加密算法无法满足我们的需求，需要更换成另外一个加密算法，这个时候应该怎么办呢？

推荐的做法是通过 `DelegatingPasswordEncoder` 兼容多种不同的密码加密方案，以适应不同的业务需求。

从名字也能看出来，`DelegatingPasswordEncoder` 其实就是一个代理类，并非是一种全新的加密算法，它做的事情就是代理上面提到的加密算法实现类。在 Spring Security 5.0 之后，默认就是基于 `DelegatingPasswordEncoder` 进行密码加密的。



**当一个 HTTP 请求到达 Spring 框架时，它会经历一系列的处理步骤。以下是详细的过程**：

1. **请求到达服务器**：
  
   - 客户端发起一个 HTTP 请求，请求通过网络到达服务器。
   
2. **DNS 解析**：
   - 服务器接收到请求后，会根据请求的域名解析出对应的 IP 地址。
   
3. **TCP 连接**：
   - 服务器使用解析出的 IP 地址与客户端建立 TCP 连接。
   
4. **发送 HTTP 请求**：
   - 服务器接收到请求后，会解析请求头（Request Header），包括请求方法（GET、POST 等）、请求路径、请求参数等。
   
5. **请求转发**：
   - 如果请求需要被转发，服务器会将请求转发到相应的后端服务。
   
6. **Spring 容器初始化**：
   - Spring 容器（ApplicationContext）根据配置文件（如 `application.properties` 或 `application.yml`）和类路径下的 Bean 定义文件（如 `spring.factories`）加载 Bean。
   
7. **请求映射**：
   - Spring 容器中的 DispatcherServlet（或类似的组件，如 Spring MVC 的其他前端控制器）会根据请求的 URL 映射到相应的 Controller 方法。
   
8. **执行 Controller 方法**：
  
   - DispatcherServlet 会调用相应的 Controller 方法，并将请求参数和上下文信息传递给该方法。
   
9. **业务逻辑处理**：
   - 在 Controller 方法中，业务逻辑会被执行。这可能包括访问数据库、调用其他服务、处理文件上传等。
   
10. **响应构建**：
  
    - Controller 方法执行完毕后，会构建一个 HTTP 响应。这个响应包括响应头（Response Header）和响应体（Response Body）。
    
11. **响应发送**：
    - DispatcherServlet 将构建好的 HTTP 响应发送回客户端。
    
12. **TCP 连接关闭**：
    - 服务器发送完响应后，关闭 TCP 连接。
    
13. **客户端接收响应**：
    - 客户端接收到响应后，根据响应头和响应体进行相应的处理。
    
      

## <font color=red>SpringMVC</font>

MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。

![](https://oss.javaguide.cn/java-guide-blog/image-20210809181452421.png)





Spring MVC的核心组件：

记住了下面这些组件，也就记住了 SpringMVC 的工作原理。

- **`DispatcherServlet`**：**核心的中央处理器**，负责接收请求、分发，并给予客户端响应。
- **`HandlerMapping`**：**处理器映射器**，根据 URL 去匹配查找能处理的 `Handler` ，并会将请求涉及到的拦截器和 `Handler` 一起封装。
- **`HandlerAdapter`**：**处理器适配器**，根据 `HandlerMapping` 找到的 `Handler` ，适配执行对应的 `Handler`；
- **`Handler`**：**请求处理器**，处理实际请求的处理器。
- **`ViewResolver`**：**视图解析器**，根据 `Handler` 返回的逻辑视图 / 视图，解析并渲染真正的视图，并传递给 `DispatcherServlet` 响应客户端

![](https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/de6d2b213f112297298f3e223bf08f28.png)

**流程说明（重要）：**

1. 客户端（浏览器）发送请求， `DispatcherServlet`拦截请求。
2. `DispatcherServlet` 根据请求信息调用 `HandlerMapping` 。`HandlerMapping` 根据 URL 去匹配查找能处理的 `Handler`（也就是我们平常说的 `Controller` 控制器） ，并会将请求涉及到的拦截器和 `Handler` 一起封装。
3. `DispatcherServlet` 调用 `HandlerAdapter`适配器执行 `Handler` 。
4. `Handler` 完成对用户请求的处理后，会返回一个 `ModelAndView` 对象给`DispatcherServlet`，`ModelAndView` 顾名思义，包含了数据模型以及相应的视图的信息。`Model` 是返回的数据对象，`View` 是个逻辑上的 `View`。
5. `ViewResolver` 会根据逻辑 `View` 查找实际的 `View`。
6. `DispaterServlet` 把返回的 `Model` 传给 `View`（视图渲染）。
7. 把 `View` 返回给请求者（浏览器)

统一异常处理怎么做？

**推荐使用注解的方式统一异常处理**，具体会使用到 `@ControllerAdvice` + `@ExceptionHandler` 这两个注解 。

~~~Java
@ControllerAdvice
@ResponseBody
public class GlobalExceptionHandler {

    @ExceptionHandler(BaseException.class)
    public ResponseEntity<?> handleAppException(BaseException ex, HttpServletRequest request) {
      //......
    }

    @ExceptionHandler(value = ResourceNotFoundException.class)
    public ResponseEntity<ErrorReponse> handleResourceNotFoundException(ResourceNotFoundException ex, HttpServletRequest request) {
      //......
    }
}

~~~

这种异常处理方式下，会给所有或者指定的 `Controller` 织入异常处理的逻辑（AOP），当 `Controller` 中的方法抛出异常的时候，由被`@ExceptionHandler` 注解修饰的方法进行处理。

`ExceptionHandlerMethodResolver` 中 `getMappedMethod` 方法决定了异常具体被哪个 `@ExceptionHandler` 注解修饰的方法处理异常。

~~~Java
@Nullable
  private Method getMappedMethod(Class<? extends Throwable> exceptionType) {
    List<Class<? extends Throwable>> matches = new ArrayList<>();
    //找到可以处理的所有异常信息。mappedMethods 中存放了异常和处理异常的方法的对应关系
    for (Class<? extends Throwable> mappedException : this.mappedMethods.keySet()) {
      if (mappedException.isAssignableFrom(exceptionType)) {
        matches.add(mappedException);
      }
    }
    // 不为空说明有方法处理异常
    if (!matches.isEmpty()) {
      // 按照匹配程度从小到大排序
      matches.sort(new ExceptionDepthComparator(exceptionType));
      // 返回处理异常的方法
      return this.mappedMethods.get(matches.get(0));
    }
    else {
      return null;
    }
  }

~~~

从源代码看出：**`getMappedMethod()`会首先找到可以匹配处理异常的所有方法信息，然后对其进行从小到大的排序，最后取最小的那一个匹配的方法(即匹配度最高的那个)。**

## 1）<font color='red'>*</font>对SpringMVC的理解

1、把传统MVC框架里前的Controller控制器做了拆分，分成了前端控制器Dispatcherservlet和后端控制器Controller

2、把Model模型拆分成业务层Service和数据访问层Repository

3、在视图层，可以以支持不同的视图品如Freemark、velocity、JSP等等







## MyBatis

## 1）#{}和${}的区别是什么？

\${} 是字符串拼接，通过${}可以将**传入的内容拼接在sql中且不进行jdbc类型转换**。

\#{} 是占位符，相当于**PreparedStatement使用占位符去替换参数，自动进行java类型和jdbc类型转换，可以防止sql注入**。

所以**${}字符串拼接可以拼接表名执行sql语句，但 #{}占位符只能站位参数，而不是站位表名，所以不可以执行sql语句。**

![](https://img-blog.csdnimg.cn/20191023153807910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1cnVhbnNodW4=,size_16,color_FFFFFF,t_70 )

![](https://img-blog.csdnimg.cn/20191023153823894.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1cnVhbnNodW4=,size_16,color_FFFFFF,t_70)

## 2）xml 映射文件中，除了常见的 select、insert、update、delete 标签之外，还有哪些标签?

还有很多其他的标签，**\<resultMap>、 \<parameterMap>、\<sql>、\<include>**、\<selectKey>，加上动态 sql的9个标签，**trim|where|set|foreach|if|choose|when|otherwise|bind **等，其中\<sql>为sql片段标签，通过\<include>标签引入sql片段，<selectkey〉为不支持自增的主键生成策略标签。

##3）Dao 接口的工作原理是什么?Dao 接口里的方法，参数不同时，方法能重载吗?
答：最佳实践中，**通常一个 xml 映射文件，都会写一个 Dao 接口与之对应。Dao 接口就是常说的 `Mapper` 接口**，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中 `MappedStatement` 的 id 值，接口方法内的参数，就是传递给 sql 的参数。 `Mapper` 接口是没有实现类的，**当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个 `MappedStatement`** 。

举例：`com.mybatis3.mappers. StudentDao.findStudentById` ，可以唯一找到 namespace 为 `com.mybatis3.mappers. StudentDao` 下面 `id = findStudentById` 的 `MappedStatement` 。在 MyBatis 中，每一个 `<select>`、 `<insert>`、 `<update>`、 `<delete>` 标签，都会被解析为一个 `MappedStatement` 对象

**Dao 接口里的方法可以重载，但是 Mybatis 的 xml 里面的 ID 不允许重复。**

**Mybatis 的 Dao 接口可以有多个重载方法，但是多个接口对应的映射必须只有一个，否则启动会报错。**

Dao 接口的工作原理是 JDK 动态代理，MyBatis 运行时会使用 JDK 动态代理为 Dao 接口生成代理 proxy 对象，代理对象 proxy 会拦截接口方法，转而执行 `MappedStatement` 所代表的 sql，然后将 sql 执行结果返回。

Dao 接口方法可以重载，但是需要满足以下条件：

1. 仅有一个无参方法和一个有参方法
2. 多个有参方法时，参数数量必须一致。且使用相同的 `@Param` ，或者使用 `param1` 这种

## 4）MyBatis 是如何进行分页的？分页插件的原理是什么？

答：**(1)** **MyBatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页**，而非物理分页；

​        **(2)** **可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能；**

​        **(3)** **也可以使用分页插件来完成物理分页。**

分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据select语句，添加对应的物理分页语句和物理分页参数。

举例：`select _ from student` ，拦截 sql 后重写为：`select t._ from （select \* from student）t limit 0，10`

## 5）简述 MyBatis 的插件运行原理，以及如何编写一个插件**

答：MyBatis 仅可以编写针对 `ParameterHandler`、 `ResultSetHandler`、 `StatementHandler`、 `Executor` 这 4 种接口的插件，MyBatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 `InvocationHandler` 的 `invoke()` 方法，当然，只会拦截那些你指定需要拦截的方法。

实现 MyBatis 的 `Interceptor` 接口并复写 `intercept()` 方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。

## 6）MyBatis 执行批量插入，能返回数据库主键列表吗？

答：能，JDBC 都能，MyBatis 当然也能。

## 7）MyBatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？

MyBatis 动态 sql 可以让我们在 xml 映射文件内，以标签的形式编写动态 sql，完成逻辑判断和动态拼接 sql 的功能。其执行原理为，使用 **OGNL 从 sql 参数对象中计算表达式的值，根据表达式的值动态拼接 sql，以此来完成动态 sql 的功能**。

MyBatis 提供了 9 种动态 sql 标签:

- `<if></if>`
- `<where></where>(trim,set)`
- `<choose></choose>（when, otherwise）`
- `<foreach></foreach>`
- `<bind/>`

[Mybatis 系列全解（八）：Mybatis 的 9 大动态 SQL 标签你知道几个？](https://segmentfault.com/a/1190000039335704)

## 8）MyBatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？

第一种是使用 **`<resultMap>` 标签，逐一定义列名和对象属性名之间的映射关系**。

第二种是使用 **sql 列的别名功能，将列别名书写为对象属性名**，比如 T_NAME AS NAME，对象属性名一般是 name，小写，但是列名不区分大小写，MyBatis 会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成 T_NAME AS NaMe，MyBatis 一样可以正常工作。

**有了列名与属性名的映射关系后，MyBatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回**，那些找不到映射关系的属性，是无法完成赋值的。

## 9）MyBatis 能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别

能，MyBatis 不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，

多对一查询，其实就是一对一查询

- 多种方式，常见的包括三种：
  - 第一种方式：**一条SQL语句，级联属性映射。**
  - 第二种方式：**一条SQL语句，association。**
  - 第三种方式：**两条SQL语句，分步查询。（这种方式常用：优点一是可复用。优点二是支持懒加载。）**

多对多查询，其实就是一对多查询。一对多的实现通常包括两种实现方式：

- 第一种方式：**collection**
- 第二种方式：**分步查询**



## 10）MyBatis 是否支持延迟加载？如果支持，它的实现原理是什么？

MyBatis 仅支持 **association 关联对象和 collection 关联集合对象**的延迟加载，association 指的就是一对一/多对一，collection 指的就是一对多查询。在 MyBatis 配置文件中，可以配置是否启用延迟加载 `lazyLoadingEnabled=true|false`

它的原理是，使用 `CGLIB` 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如**调用 `a.getB().getName()` ，拦截器 `invoke()` 方法发现 `a.getB()` 是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 `a.getB().getName()` 方法的调用**。这就是延迟加载的基本原理。

当然了，不光是 MyBatis，几乎所有的包括 Hibernate，支持延迟加载的原理都是一样的。

## 11）MyBatis 的 xml 映射文件中，不同的 xml 映射文件，id 是否可以重复？

不同的 xml 映射文件，**如果配置了 namespace，那么 id 可以重复；如果没有配置 namespace，那么 id 不能重复，**毕竟 namespace 不是必须的，只是最佳实践而已。 

原因就是 **namespace+id 是作为 `Map<String, MappedStatement>` 的 key 使用的，如果没有 namespace，就剩下 id，那么，id 重复会导致数据互相覆盖。**有了 namespace，自然 id 就可以重复，namespace 不同，namespace+id 自然也就不同。

## 12）MyBatis 中如何执行批处理？

答：使用 **BatchExecutor** 完成批处理。

## 13）MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？

MyBatis 有三种基本的 `Executor` 执行器：

- **`SimpleExecutor`(默认)：** 每执行一次 update 或 select，就开启一个 Statement 对象，用完立刻关闭 Statement 对象。
- **`ReuseExecutor`：** 执行 **update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放置于 Map<String, Statement>内，供下一次使用。**简言之，就是重复使用 Statement 对象。
- **`BatchExecutor`**：执行 update（没有 select，JDBC 批处理不支持 select），将所有 sql 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它**缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理**。与 JDBC 批处理相同。

作用范围：`Executor` 的这些特点，都**严格限制在 SqlSession 生命周期范围内**。



## 14）MyBatis 中如何指定使用哪一种 Executor 执行器？

答：在 MyBatis 配置文件中，可以指定默认的 **`ExecutorType` 执行器类型**，也可以手动给 `DefaultSqlSessionFactory` 的创建 SqlSession 的方法传递 `ExecutorType` 类型参数。

## 14) 谈谈你对SqlsessionFactory的理解

它是个单个数据库映射关系经过编译后的内存镜像。

SqlSessionFactory对象的实例可以通过SqlSessionFactoryBuilder对象类获得，而**SqlSessionFactoryBuilder则可以从XML配置文件或一个预先定制的Configuration的实例构建出SqlSessionFactory的实例**。每一个MyBatis的应用程序都以一个SqlSessionFactory对象的实例为核心。

同时**SqlSessionFactory也是线程安全的,SqlSessionFactory一旦被创建,应该在应用执行期间都存在。在应用运行期间不要重复创建多次，建议使用单例模式。SqlSessionFactory是创建SqlSession的工厂**。

## 15）谈谈你对SqiSession的理解

SqlSession是mybatis中非常核心的一个API：作用是通过**相关API来实现对应的数据库数据的操作**。

SqlSession对象的获取需要通过**SqlSessionFactory**来实现。

**是一个会话级别的**。

**当一个新的会话到来时，我们需要新建一个SqlSession对象来处理。当一个会话结束后我们需要关闭相关的会话资源。**处理请求的方式：

- 通过相关的增删改查的API来处理
- 可以通过getMapper（XXX.class）来获取相关的Mapper接口的代理对象来处理

## 16）MyBatis 是否可以映射 Enum 枚举类？

答：**MyBatis 可以映射枚举类，不单可以映射枚举类，MyBatis 可以映射任何对象到表的一列上**。

映射方式为自定义一个 **`TypeHandler`** ，实现**`TypeHandler` 的 `setParameter()` 和 `getResult()`** 接口方法。 `TypeHandler`有两个作用：

- 一是完成从 javaType 至 jdbcType 的转换；
- 二是完成 jdbcType 至 javaType 的转换，体现为 `setParameter()` 和 `getResult()` 两个方法，分别代表设置**sql 问号占位符参数和获取列查询**结果。



## 17）MyBatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？

**虽然 MyBatis 解析 xml 映射文件是按照顺序解析的，但是，被引用的 B 标签依然可以定义在任何地方，MyBatis 都可以正确识别。**

原理是，MyBatis 解析 A 标签，发现 A 标签引用了 B 标签，但是 B 标签尚未解析到，尚不存在，此时，MyBatis 会**将 A 标签标记为未解析状态**，然后继续解析余下的标签，包含 B 标签，待所有标签解析完毕，**MyBatis 会重新解析那些被标记为未解析的标签**，此时再解析 A 标签时，B 标签已经存在，A 标签也就可以正常解析完成了。



## 18）简述 MyBatis 的 xml 映射文件和 MyBatis 内部数据结构之间的映射关系？

答：**MyBatis 将所有 xml 配置信息都封装到 All-In-One 重量级对象 Configuration 内部**。

在 xml 映射文件中， `<parameterMap>` 标签会被解析为 **`ParameterMap`** 对象，其每个子元素会被解析为 **ParameterMapping** 对象。 

`<resultMap>` 标签会被解析为 **`ResultMap`** 对象，其每个子元素会被解析为 **`ResultMapping`** 对象。

每一个 `<select>、<insert>、<update>、<delete>` 标签均会被解析为 **`MappedStatement`**对象，标签内的 sql 会被解析为 **BoundSql **对象。

##19）为什么说 MyBatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？

答：

Hibernate 属于全自动 ORM 映射工具，使用 Hibernate **查询关联对象或者关联集合对象**时，可以根据**对象关系模型**直接获取，所以它是全自动的。

而 MyBatis 在**查询关联对象或关联集合对象**时，需要**手动编写 sql **来完成，所以，称之为半自动 ORM 映射工具。



## 20）<font color="red">Mybatis的一级、二级缓存，何时使用？有什么缺点？</font>

**二级缓存：**mybatis默认是没有开启二级缓存的，二级缓存需要我们手动开启，它是mapper级别的缓存；

使用的是`CachingExecutor`对象，它是对`Executor`的一个封装，在一级缓存之前，会先进行二级缓存查询。二级缓存被多个SqlSesion共享，是一个全局缓存。

**二级缓存是建立在同一个namespace下的，如果对某一个表的操作查询可能有多个namespace**，那么会得到脏数据。

**一级缓存：**一级缓存是默认开启的；不同sqlsession之间缓存互不影响。

在sqlsession里面有个Executor对象，每个Executor对象都会有一个LocalCache的一个对象，用户发起查询时，Mybatis根据查询语句去Local Cache里面去查询，如果没有命中的话，再去查询数据库，并且写入到Local Cache里面，否则直接返回。如果在多个sqlsession或者分布式环境下，会出现脏数据（数据一致性问题）。

———>>>当多个SQL会话同时操作数据库时，可能会出现脏数据的问题。这是因为每个会话都有自己的缓存，如果某个会话更新了数据库中的数据，其他会话的缓存可能仍然包含旧的数据。

![image-20240522174956355](Redis.assets/image-20240522174956355.png)

**改进？**

统一使用第三方插件来做缓存，如redis，mamcache等，
		关闭mybatis的一级缓存和二级缓存，
		mybatis仅仅只限于orm框架，数据库和对象的映射，以及操作sql。



## SpringBoot

## **1. Spring Boot 有哪些特点？**

- **自动配置**

这是 Spring Boot 最重要的特性。这极大地消除了手动配置。基础框架附带了一个名为 auto-configure 的内置库，它为我们完成了这项工作。它检测某些类的存在以及类路径上的存在，并为我们自动配置它们。

例如：— 当我们在项目中添加spring-boot-starter-web依赖项时，Spring Boot 自动配置会查找 Spring MVC 是否在类路径中。它自动配置dispatcherServlet、默认错误页面和web jars。— 同样，当我们添加
spring-boot-starter-data-jpa依赖项时，我们会看到 Spring Boot 自动配置，自动配置一个数据源和一个实体管理器。

- **嵌入式 Tomcat Web 服务器**

Spring Boot 默认随 Tomcat 服务器一起提供。因此，我们不需要配置服务器来运行应用程序（如果我们的首选服务器是 Tomcat）。

- **入门 POM**

Spring Boot 本身提供了许多启动 POM 来完成开发生活中最常见的任务。我们可以依赖它们和框架本身，而不需要去第三方库。



## **2、“@SpringBootApplication”注解在内部是如何工作的**

启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：

- - **@SpringBootConfiguration**：组合了 @Configuration 注解，实现配置文件的功能。
  - **@EnableAutoConfiguration**：打开自动配置的功能，也可以关闭某个自动配置的选项， 例如：java 如关闭数据源自动配置功能： @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。
  - **@ComponentScan**：Spring组件扫描。

- 

- 

- 

## **3. 什么是 Bean？**

Bean 只是普通的 Java 对象。在 Spring Boot 上下文中，它们被视为 Java 对象 + 在应用程序启动时自动初始化并由 Spring IOC 容器管理的对象。我们有“@Bean”注解来实现这一点。

##<font color=red>**4、 什么是Spring中的控制反转（IOC）？**</font>



##**5、我们如何在Spring Boot中实现依赖注入？**

将对象作为依赖项传递给另一个对象

在 Spring Boot 中，我们可以使用“@Autowired”注解来实现这一点。然后 Spring IOC 容器将代表我们创建对象。通常，在控制器层我们注入服务，在服务层我们注入存储库来使用这个注解。

##**6、Spring Boot微服务有哪些层？**

控制器层：所有具有 API 端点定义方法的控制器。类使用“@RestController”注解进行注解。
		Repository/DAO层：所有repository接口都包含在这一层中，用于查询已选择的数据库（SQL/no SQL）。接口使用“@Repository”注解进行注解。
		服务层：所有业务逻辑都包含在这里。通常在该层访问DAO层以执行一些操作。类使用“@Service”注解进行注解。
		实体层：映射到现实世界的所有类都包含在该层中。通常所有与 ORM 相关的注释都放在这些类中。— 如果它与 MySQL 连接，我们用“@Entity”注释表名。— 如果它连接到 MongoDB，我们用“@Document”注释集合名称
此外，我们可以使用 Lombok 之类的库在此处定义 getter 和 setter。

## 7、 **如何使用 Spring Boot 连接数据库？**

通常我们不需要创建单例数据库类、连接池方法和任何其他实现。SpringBoot AutoConfiguration 将为我们完成所有这些类和配置设置。只需要设置。

将数据库（MySQL/MongoDB/Redis）的启动器依赖项添加到 POM。
在 application.properties/yml 文件中定义配置 - 例如：数据库 URL 和凭据

##8、**如何在DAO层编写自定义查询？**



##9、**Spring Boot 中如何处理事务？使用的任何注释？**

Spring Boot 提供了一个名为“@Transactional”的注解来管理事务。

##10、**我们需要在哪里使用“@Qualifier”注解？**

此注解用于专门告诉 Spring Boot 从其所有可用实现 bean 中获取特定类。@Qualifier注解与“ @Autowired”注解一起用于依赖注入。

显示指定注入那个实现类

##11、**Spring Boot项目中可以替换Tomcat服务器吗？**

是的。如果需要，我们可以通过在 POM 中添加 maven 排除来删除 Tomcat 服务器。实际上，Web 服务器捆绑在started-web Spring Boot starter 依赖项中。应该添加排除。

```Java
<dependency> 
  <groupId>org.springframework.boot</groupId> 
  <artifactId>spring-boot-starter-web</artifactId> 
  <exclusions> 
    <exclusion> 
      <groupId>org.springframework.boot</groupId> 
      <artifactId> spring-boot-starter-tomcat</artifactId> 
    </exclusion> 
  </exclusions> 
</dependency>
```

```Java
<dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-jetty</artifactId> </dependency><dependency> 
  <groupId>org.springframework.boot</groupId> 
  <artifactId>spring-boot-starter-jetty</artifactId> //添加jetty服务器
</dependency>
```

##12、**“@PathVariable”和“@RequestParam”有什么区别？**

PathVariable - 当我们设置 API 端点时使用以“/”分隔的参数。restful风格

RequestParam - 当我们设置 API 端点时使用，查询参数以“&”分隔并以“？”开头。

##13、**“@Primary”注解有什么用？**

@Primary表示当多个候选者有资格自动连接单值依赖项时，应优先考虑 bean。

##14、**如何验证传入的请求并将错误通知给用户**?

将启动器验证依赖项添加到 POM 中

```Java
<dependency> 
   <groupId>org.springframework.boot</groupId> 
   <artifactId>spring-boot-starter-validation</artifactId> 
</dependency>
```

在“RequestBody”注解前添加“@Valid”注解。

为要显示验证约束消息的请求创建单独的 DTO。

使用“@RestControllerAdvice”创建全局异常处理程序，并在单独的方法中处理
MethodArgumentNotValidException 。

创建逻辑以根据需要将错误返回给最终用户。我们可以在这个 logic.es 中提取异常消息


##15、**什么是Spring Boot Actuator？**

简单地说，Spring Boot 框架的一个子项目，它使用 HTTP 端点来公开有关任何正在运行的应用程序的操作信息。

这些信息包括应用程序指标、连接的数据库状态、应用程序状态、bean 信息、请求跟踪等。

它可作为启动器依赖项使用。我们可以通过安装以下依赖项来使用该库。

```Java
<dependency> 
    <groupId>org.springframework.boot</groupId> 
    <artifactId>spring-boot-starter-actuator</artifactId> 
</dependency>
```

##16、**Spring Boot微服务中的异常如何处理？**

我们需要一个全局配置类，为每个异常类预定义异常处理方法。我们也可以使用处理程序本身定义返回的 HTTP 状态代码。

- 使用“@RestControllerAdvice”创建一个全局异常处理程序，并在单独的方法中处理每个异常。

- 创建逻辑以根据需要将错误返回给最终用户。我们可以在这个逻辑中提取异常消息

  

##17、**“@Entity”和“@Table”注解有什么区别？**

@Entity实体表示将在程序中使用的类，@Table表示将通过程序访问的实际数据库表。



##18、讲讲SpringBoot的启动过程

1. **启动类和@SpringBootApplication注解**：
   - 首先，Spring Boot 应用程序有一个启动类，该类包含了一个 main 方法。
   - 在启动类上，通常会使用 `@SpringBootApplication` 注解。这个注解是一个组合注解，它整合了 `@Configuration`、`@EnableAutoConfiguration` 和 `@ComponentScan`。
2. **执行 SpringApplication.run() 方法**：
   - 在 main 方法中，通过调用 `SpringApplication.run()` 方法来启动 Spring Boot 应用程序。

1. **创建 SpringApplication 实例**：
   - `SpringApplication` 类负责启动 Spring 应用程序。在调用 `run` 方法之前，会创建一个 `SpringApplication` 实例。
   - 在这个过程中，会进行一些初始化操作，比如确定应用程序的类型（REACTIVE、SERVLET 等）。
2. **准备环境（Environment）**：
   - Spring Boot 会配置和准备应用程序运行的环境，这包括创建 `Environment` 对象，该对象包含了各种属性源，比如系统属性、环境变量、application.properties 或 application.yml 文件中的属性。
3. **创建ApplicationContext**：
   - 根据 `SpringApplication` 实例中的信息，创建相应的 `ApplicationContext`（类型可能是 `AnnotationConfigServletWebServerApplicationContext`、`AnnotationConfigReactiveWebServerApplicationContext` 等）。
   - `ApplicationContext` 是 Spring 的核心概念，负责应用程序的创建、配置和管理。
4. **执行 Initializers**：
   - 调用 `ApplicationContextInitializer` 的 `initialize` 方法，这些初始化器是在创建 `ApplicationContext` 之前用来执行一些初始化操作的。
5. **执行 Listeners**：
   - 在 `ApplicationContext` 准备好之后，但是创建任何 beans 之前，会通知 `ApplicationListener` 事件。
6. **刷新 ApplicationContext**：
   - 调用 `ApplicationContext` 的 `refresh` 方法，这个步骤是 Spring 容器启动的核心。
   - 在这个阶段，Spring Boot 会加载所有单例 beans，并执行相关的生命周期回调。
7. **调用 CommandLineRunner 和 ApplicationRunner**：
   - 如果定义了任何 `CommandLineRunner` 或 `ApplicationRunner` beans，Spring Boot 将在这里调用它们。
   - 这通常用于在应用程序启动后执行一些特定的代码。
8. **启动 Web Server**（如果有的话）：
   - 如果应用程序是一个 Web 应用，Spring Boot 会启动嵌入的 Web 服务器（比如 Tomcat、Jetty 或 Undertow）。





# Redis

https://www.bilibili.com/video/BV1cr4y1671t/?vd_source=03235a8277a4e1950048927a7c975e38

配合：https://www.bilibili.com/video/BV1cr4y1671t/?vd_source=03235a8277a4e1950048927a7c975e38

E:\java\mybatis\respository\org\apache\maven\maven-model-builder\3.1.0222

![image-20240508193113664](Redis.assets/image-20240508193113664.png)

## 1、什么是 Redis？Redis 有哪些特点？Redis 有哪些常⻅的应⽤场景？

Redis 是基于内存的键值型（key - value）的 NoSQL 数据库（⾮关系型数据库）。key ⼀般是 String 类型，⽽  value ⽀持丰富的数据类型，包括**String、Hash、List、Set、SortedSet** 这五种基本类型，此外还有 **GEO、 BitMap、HyperLogLog** 等其他类型。

Redis 有哪些特点？

- 读写性能优异
  - **基于内存，内存的访问速度是⽐磁盘快很多的**
  - **采⽤单线程模型，不存在多线程的上下⽂切换，不需要考虑锁的问题**
  - 使⽤ IO 多路复⽤模型，让 **Redis 不需要创建额外的线程来监听客户端的大量请求**，减少性能的消耗
  - 内置了多种优化过的数据结构实现

- 所有**操作命令都是原⼦性的**
- ⽀持事务
  -  允许多个命令按顺序执⾏并不会被打断
  - 不⽀持回滚

- ⽀持数据持久化
  -  **RDB：通过创建快照来获得存储在内存⾥⾯的数据在某个时间点上的副本**
  - **AOF：执⾏完更改数据的命令后，会将该命令记录到⽇志中**

- ⽀持分布式部署

![image-20240329204556712](Redis.assets/image-20240329204556712.png)

![image-20240329204624087](Redis.assets/image-20240329204624087.png)

![image-20240329204700860](Redis.assets/image-20240329204700860.png)

## 2、讲⼀下 Redis 的单线程模型，IO 多路复⽤是什么？

单线程

------

​    **Redis**它采用单线程模型来处理客户端请求。**这里的单线程指的是**Redis服务器进程中**只有一个主线程来处理所有的网络I/O、数据读写、命令执行等任务**，而不是像传统的多线程服务器一样，每个连接都会创建一个新的线程来处理。

​    Redis采用**单线程模型的主要原因是为了避免多线程带来的线程切换、锁竞争等开销，从而提高系统的吞吐量和响应速度**。此外，单线程模型还可以简化系统的设计和实现，减少出错的概率。

IO多路复用

------

**同时监听多个文件描述符**（sockets或者文件等），能够有效地管理多个IO事件并在事件发生时作出相应的处理。在Redis中，IO多路复用机制通常是**通过select、poll、epoll这些系统调用来实现**的，具体选择哪种机制取决于操作系统和性能需求。这些机制都可以监视多个文件描述符，并在有事件发生时通知应用程序，从而实现同时管理多个IO事件的能力。

通过IO多路复用机制，Redis可以在**一个线程中同时监听多个客户端连接的IO事件**，当有数据到达或连接就绪时，Redis可以立即作出响应，而不需要为每个连接创建一个单独的线程或进程，从而减少了系统资源的开销，**提高了IO处理的效率。（redis快的原因之一）**

  总的来说，Redis使用IO多路复用机制可以更高效地处理多个IO事件，提高系统的性能和响应速度，是一种常见的IO处理方式，尤其适用于需要高效处理大量并发IO请求的场景。

------

###1.1 文件描述符（sockets或者文件等）是什么？

 文件描述符是**操作系统中**用来**标识**打开文件、网络连接或其他**I/O资源的整数值**。在Unix和类Unix系统中，一切皆文件的思想下，文件描述符可以用来唯一标识一个打开的文件、**套接字（sockets）**、**管道等**I/O资源。

 在Redis中，文件描述符主要用来标识与客户端的网络连接，以便进行数据读写操作。Redis使用文件描述符来管理多个客户端连接，实现高效的IO多路复用。

### 1.2 套接字（sockets）是什么？

套接字（sockets）是在网络编程中用于实现网络通信的一种机制。**套接字是由IP地址和端口号组合而成的**，通过套接字可以在网络中传输数据。在网络编程中，**客户端和服务器通过套接字进行通信**。客户端通过创建一个套接字并连接到服务器的套接字来发起请求，而服务器则监听特定的套接字，接受客户端的连接请求，并与客户端进行通信。

  **套接字**可以**分为两种类型**：流套接字（SOCK_STREAM）和数据报套接字（SOCK_DGRAM）。流套接字提供面向连接的、可靠的数据传输，如TCP协议；数据报套接字提供无连接的、不可靠的数据传输，如UDP协议。

  在Redis中，套接字常用于表示与客户端建立的网络连接。Redis服务器通过套接字与客户端进行通信，接收客户端的请求并返回响应。通过套接字，Redis实现了与客户端之间的数据交换和通信，支持网络访问和操作。

### 1.3 I/O资源中的管道是什么意思？

I/O资源中的**管道（Pipe）是**一种在**Unix和类Unix操作系统**中用于**进程间通信**的机制。

  管道是由操作系统内核维护的一个缓冲区，它可以连接两个进程，其中**一个进程的输出会直接成为另一个进程的输入**。这样，通过管道可以实现进程之间的数据交换和通信，而无需借助临时文件等额外的存储介质。

  在Unix系统中，管道通常使用竖线符号（|）来连接两个命令，例如，`command1 | command2` 就表示将 `command1` 的输出作为 `command2` 的输入。

### 1.4 Unix和类Unix操作系统是什么意思？

Unix和类Unix操作系统指的是一类操作系统，它们的设计灵感来自于原始的Unix操作系统，或者在设计上借鉴了Unix的特性和思想，因此被称为“类Unix”操作系统。

类Unix操作系统通常具有以下**特点**：

1. 遵循Unix操作系统设计思想：包括一切皆文件、小即是美、可编程接口等。
2. 提供类似Unix的命令行界面和工具：如shell、grep、awk等。
3. 支持类Unix的标准：如POSIX标准（Portable Operating System Interface）等。

**常见的**类Unix操作系统包括但不限于：

- Linux：最知名的开源类Unix操作系统，由Linus Torvalds发起并得到全球开发者社区的支持。
- MacOS：苹果公司基于BSD Unix开发的操作系统。
- Solaris：甲骨文公司开发的商用Unix操作系统。
- BSD（Berkeley Software Distribution）：源自加州大学伯克利分校的Unix衍生版操作系统。

###1.5 在计算机系统中，**I/O资源包括**：

1. 各种**外部设备**（如硬盘、键盘、鼠标、打印机等）

2. **网络接口** :

   网络接口：网络接口用于连接计算机系统与网络之间进行数据传输。计算机系统通过网络接口可以访问 Internet、局域网或广域网等。例如，无线网卡用于连接无线网络，以实现无线上网功能。

3. **数据传输的通道和总线** 

   数据传输通道和总线用于在计算机内部和外部设备之间进行数据传输和通信。总线是计算机内部各个组件之间的数据传输通道，不同类型的总线用于连接 CPU、内存、显卡等设备。例如，PCI Express 总线用于连接显卡和主板，实现高速数据传输。

### 1.6 IO多路复用机制中select、poll、epoll这些系统调用分别是什么？

**select**:

- `select`是早期的I/O多路复用系统调用，它允许程序监视一组文件描述符，等待其中一个或多个变得“就绪”（可读、可写或有异常）。
- `select`的主要缺点是它**支持的文件描述符数量有限**（通常受限于`FD_SETSIZE`），并且每次调用都需要重新传递整个文件描述符集合和对应的感兴趣事件，这导致在高并发情况下性能较差。
- `select`在多核处理器上扩展性不好，因为它只能在一个线程中运行

**poll**:

- `poll`系统调用与`select`类似，但它**没有文件描述符数量的限制**，因为它是通过一个数组来传递文件描述符和事件信息的，这个数组的长度可以自由设置。
- `poll`解决了`select`在文件描述符数量上的限制问题，但在处理大量文件描述符时，性能仍然是一个问题，因为每次**调用都需要遍历整个数组**。

**epoll**:

- `epoll`是Linux特有的I/O多路复用机制，它提供了比`select`和`poll`更高效的解决方案。
- `epoll`通过一个称为**“事件表”的数据结构来管理文件描述符，这使得它可以非常快速地检测到就绪的文件描述符**，不需要像`select`和`poll`那样每次调用都遍历所有文件描述符。
- `epoll`支持**边缘触发（ET）和水平触发（LT）**两种模式，边缘触发模式在性能上更有优势，因为它只在状态变化时通知，而不是在每次可读或可写时都通知。
- `epoll`还可以与线程池结合使用，以充分利用多核处理器的性能。

**epoll_ctl，将要监听的fd加到红黑树中，并使用回调函数监听，发生事件，内核去准备好数据，数据就绪，就将这些fd添加到链表，然后复制到用户空间，用户态就知道哪些fd准备好了，再把对应的数据取出来进行响应**

![image-20240810122017691](C:\Users\耀\AppData\Roaming\Typora\typora-user-images\image-20240810122017691.png)

##3、Redis 基础类型中的 String 底层实现是什么？

String 底层实现是 SDS，也就是**动态字符串**。 

Redis当中的动态字符串主要是**对C语⾔中的做了⼀个封装**，使得SDS具有**动态扩容、O(1)复杂度的⻓度计算**的特点。 并且避免了C字符串**缓冲区溢出**（C字符串不记录⾃身⻓度）。

当 **SDS API 需要对 SDS 进⾏修改时，API 会先检查 SDS 的空间是否满⾜修改所需的要求，如果不满⾜的话，API 会⾃动将 SDS 的空间扩展⾄执⾏修改所需的⼤⼩**

SDS主要由三个部分组成：

- len **实际使⽤**⻓度 ---->查询

- free buf数组中**未使⽤字节**的数量 ---->动态扩容

  - 空间预分配

    空间预分配用于优化 SDS 的字符串增长操作： 当 SDS 的 API 对一个 SDS 进行修改， 并且需要对 SDS 进行空间扩展的时候， 程序不仅会为 SDS 分配修改**所必须要的空间， 还会为 SDS 分配额外的未使用空间**

    - <1MB,程序分配和 `len` 属性同样大小的未使用空间， 这时 SDS `len` 属性的值将和 `free` 属性的值相同。
    - \>=1MB,那么程序会分配 `1 MB` 的未使用空间。

  - 惰性空间释放

    惰性空间释放用于优化 SDS 的字符串缩短操作： 当 SDS 的 API 需要缩短 SDS 保存的字符串时， 程序并不立即使用内存重分配来回收缩短后多出来的字节， 而是使用 `free` 属性将**这些字节的数量记录起来， 并等待将来使用。**

     SDS 也提供了相应的 API ， 让我们可以在有需要时， **真正地释放 SDS 里面的未使用空间**。

- char buf[] ⽤于**保存字符串**

##4、如何使用Redis 实现⼀个排⾏榜？

![image-20240421095820604](Redis.assets/image-20240421095820604.png)

![image-20240421095841967](Redis.assets/image-20240421095841967.png)

![image-20240421095854810](Redis.assets/image-20240421095854810.png)

## 5、Redis 的持久化机制有哪些？说说各⾃的优缺点和应⽤场景？

![image-20240421095644996](Redis.assets/image-20240421095644996.png)

![image-20240421095700009](Redis.assets/image-20240421095700009.png)

##6、如何⽤ Redis 实现分布式 Session？

分布式 session 指在多个服务器间共享 session，我们可以使⽤ redis 来存储 session 来实现该功能。

在 redis 中我们通常使⽤ Hash 来存储 session。

具体的步骤如下：

1. ⽤户登录成功后，将 Session 存到 redis 中 

2.  将key设置为⼀个全局 id，格式可以采⽤“session:token”，其中 token 为 sessiond 的唯⼀标识。 

3. 将 session 的唯⼀标识 token 以 cookie 的形式返回给客户端，客户端在后续请求中都会携带这个 cookie。 

4. 后续请求中，服务器拿到客户端传来的 cookie，并根据它的值，也就是 token，去 **redis** 找对应的 session  数据。 

5. ⽤户退出登录后，将 session 删除。

   

   可以使⽤ Redis 的 **EXPIRE** 命令来设置 **Session 数据的过期时间**，这样可以⾃动删除**已经过期的 Session** 数据。

   同时，还需要注意保护 Redis 中的 Session  数据不被恶意攻击者窃取，⼀般可以通过设置 Session 数据的前缀和使 ⽤随机的 Session ID 等⽅式来提⾼安全性。

## 7、讲⼀下 Redis 中的内存淘汰机制、有哪些内存淘汰策略？

![image-20240421095340309](Redis.assets/image-20240421095340309.png)

![image-20240421095356981](Redis.assets/image-20240421095356981.png)

![image-20240421095456550](Redis.assets/image-20240421095456550.png)

## 8、Redis 6.0 之后为何引入了多线程？6.0 之前为什么不使⽤多线程？

![image-20240421095126205](Redis.assets/image-20240421095126205.png)

主二，+充分利用了**CPU多核的计算能力**。

<img src="Redis.assets/image-20240509094608084.png" alt="image-20240509094608084" style="zoom: 50%;" />

##9、Redis 有哪些数据类型？基础数据结构有⼏种？你还知道哪些 Redis  的⾼级数据结构？

![image-20240421094954859](Redis.assets/image-20240421094954859.png)

![image-20240421095014099](Redis.assets/image-20240421095014099.png)

##10、Redis 为什么快？

**1、纯内存操作** 

Redis 是基于内存的数据存储系统，绝⼤部分请求是纯粹的内存操作。 

**2、单线程操作，避免了频繁的上下⽂切换** 

Redis 的单线程操作是指，Redis 使⽤⼀个主线程来处理所有的客户端请求和数据操作，不会创建新的线程来处理请求。这种单线程模型的优点是可以避免多线程并发访问共享数据时的竞争和死锁问题，从⽽提⾼了 Redis 的性能和稳定性。此外，由于 Redis 的内存访问速度⾮常快，因此单线程处理请求也能够保证⾜够的性能。 

**3、采⽤了非阻塞 I/O 多路复⽤机制** 

为了实现单线程模型，Redis 使⽤了 IO 多路复⽤技术。IO 多路复⽤是指操作系统提供的⼀种 IO 模型，可以让**⼀个进程同时监听多个 IO 事件（如读写事件）**，并在有事件发⽣时通知进程，从⽽实现并发处理 IO 事件。 具体来说，在 Redis 中，客户端的请求是由⼀个单线程来处理的，⽽ IO 操作却是通过 **epoll 多路复⽤技术实现** 的。

Redis 单线程情况下，内核会⼀直监听 socket 上的连接请求或者数据请求，⼀旦有请求到达就交给 Redis 线程处理，这就实现了⼀个 Redis 线程处理多个 IO 流的效果。 select/epoll 提供了基于事件的回调机制，即针对不同事件的发⽣，调⽤相应的事件处理器。所以 Redis ⼀直在处理事件，提升 Redis 的响应性能。

![image-20240417224837032](Redis.assets/image-20240417224837032.png)



##11、如何使⽤ Redis 实现分布式锁？

基于 Redis 的分布式锁实现思路：

- 利⽤ **setnx 获取锁，并设置过期时间，保存线程标识**
  - **uuid+ 线程 id 因为不同服务器线程 id 有可能⼀样, 所以拼接 uuid**

- **释放锁时先判断线程标识是否与⾃⼰⼀致，⼀致则删除锁**
  - **判断锁是否为⾃⼰的然后再释放, 这个过程必须是原⼦性的否则有可能释放别⼈的锁, 这就需要 lua 脚本**。

特性：

- 利⽤ set nx 满⾜互斥性
- 利⽤ set ex 保证故障时锁依然能释放，避免死锁，提⾼安全性
- 利⽤ Redis集群保证⾼可⽤和⾼并发特性

**可重⼊**

- 和 jdk 的可重⼊锁的原理是⼀致的

- 使⽤ hash类型, key 为 userId 或者商品 id , field 为线程 id, value 为数字。 加锁解锁都需要使⽤ lua 脚本

  - 加锁
    - 判断 key 是否存在, 不存在则直接加锁, 加**过期时间** (key 为 userId 或者商品 id , field 为线程 id,  value 为 1)
    - 存在则说明有⽅法已经加了锁，此时判断 field 的线程 id 是否则⾃⼰⼀致(是否为同⼀线程)，不同则返回, 相同则 value+1, 然后设置过期时间

  - 加锁后执⾏流程
    - ⽅法 1 加锁后, value=1, ⽅法1调⽤⽅法2
    - ⽅法 2 加锁, redisson 判断锁标识是否是⾃⼰(field 字段是否为同⼀线程)，若是则 value++，value 为  2
    - 同理, ⽅法 3 加锁，value=3

- 释放锁	

  - 判断锁是否是⾃⼰线程的. 不是则退出。是则 value-1

  - 判断重复次数 value 是否为 0, 如果为 0 则释放锁。不为 0 说明锁其他⼈还在⽤, 则重置有效期

- 释放锁执⾏流程
  - ⽅法 3 执⾏完毕， 释放锁，value--， value=2
  - ⽅法 2 释放锁，value=1
  - ⽅法 1 释放锁， value=0，此时删除 redis 的该数据，锁完全释放
  - **可重试**：**利⽤信号量和 redis 的 pubsub 发布订阅机制实现等待、唤醒，获取锁失败的重试机制**

- 先直接获取锁, 如果获取失败, 并不是直接重试， 因为现在⽴即重试⼤概率其他线程正在执⾏业务，获取锁失败会先暂时等待。 (CPU 占⽤率不会很⾼, 性能不错)
- 获取锁成功的线程在释放锁时会发布⼀条消息。
- 当其他线程得到该消息时, 就会重新获取锁，如果再次获取锁失败，就会再次等待.
- 但是不是⽆限制的等待, 因为他会有⼀个等待时间, 超过该时间则不重试直接返回 false

**超时续约**：利⽤ watchDog，每隔⼀段时间(releaseTime/3)，重置超时时间

- 看⻔狗机制会创建⼀个守护线程, 当锁快到期但是业务线程没执⾏完时为锁增加时间 (续命). 
- 当然看⻔狗也不会⽆限地增加超时时间, redisson ⼀个参数⽤来设置加锁的时间, 超过这个时间后锁便⾃动解开了，不会延⻓锁的有效期。 

主从⼀致性问题：使⽤多个独⽴的 Redis 节点

- 获取锁时, 往每⼀个 redis 节点都写⼊ key。即便其中⼀台 redis 宕机, 其他 redis 依旧有锁信息.
- 并且必须在所有节点都获取到锁, 才算获取锁成功. 
- Redisson 分布式联锁 RedissonMultiLock 对象可以将多个 RLock 锁对象关联为⼀个联锁, 可以把⼀组锁当作 ⼀个锁来加锁和释放。

##12、如何⽤ Redis 中的 HyperLogLog 统计⻚⾯ UV?

HyperLogLog 是⽤于做基数统计的结构，在输⼊量⾮常⼤的时候,⾮常好⽤

- 12k的⼤⼩可以记录 2^64 次⽅个不同元素 
- 误差极⼩ 0.81%

我⽤的可是上流的 SpringBoot,为什么要⽤ Jedis? 使⽤ **HyperLogLog统计 UV**

![image-20240421090943401](Redis.assets/image-20240421090943401.png)

## 13、Redis与MySQL双写一致性如何保证？

<img src="https://img-blog.csdnimg.cn/img_convert/06adb1af94e5549b9f764123afe4ac5f.png" style="zoom: 80%;" />

![image-20240509132603722](Redis.assets/image-20240509132603722.png)

缓存更新----主动更新策略

- Cache-Aside Pattern，即旁路缓存模式，它的提出是为了尽可能地解决缓存与数据库的数据不一致问题。

| <img src="https://img-blog.csdnimg.cn/img_convert/2448bc86d5cd4ad71d7c9fdfb87d2b9e.png" style="zoom: 67%;" /> | ![](https://img-blog.csdnimg.cn/img_convert/84658600d3c53a815110fc025987c726.png) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

- Read-Through/Write-Through（读写穿透）

Read/Write-Through模式中，服务端把**缓存作为主要数据存储**。应用程序跟数据库缓存交互，都是通过**抽象缓存层**完成的

| <img src="https://img-blog.csdnimg.cn/img_convert/248df8d8cf82c3cb9fe82aa1d378560a.png"  /> | <img src="https://img-blog.csdnimg.cn/img_convert/27617e03937ba6e112f371e701b72b2c.png"  /> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

Write-behind 跟Read-Through/Write-Through有相似的地方，都是由Cache Provider来负责缓存和数据库的读写。它们又有个很大的不同：Read/Write-Through是同步更新缓存和数据的，Write-Behind则是只更新缓存，**不直接更新数据库，通过批量异步的方式来更新数据库**。

<img src="https://img-blog.csdnimg.cn/img_convert/071df696f466eaec62fce2124641acdb.png" style="zoom:67%;" />

这种方式下，缓存和数据库的一致性不强，对一致性要求高的系统要谨慎使用。但是它适合频繁写的场景，MySQL的**InnoDB Buffer Pool机制**就使用到这种模式。



**操作缓存的时候，到底是删除缓存呢，还是更新缓存？**

更新缓存，会出现缓存和数据库数据不一致的问题。

**双写的情况下，先操作数据库还是先操作缓存？**

先操作数据库再删除缓存。

**数据库和缓存数据保持强一致，可以嘛**？

实际上，没办法做到数据库与缓存绝对的一致性。**追求绝对一致性的业务场景，不适合引入缓存。**

3种方案保证数据库与缓存的一致性

- **缓存延时双删**（第二次删除缓存失败）

<img src="https://img-blog.csdnimg.cn/img_convert/4273535059bf3e82101669d77bde93e6.png" style="zoom:33%;" />

- **删除缓存重试机制**（会造成好多业务代码入侵）

<img src="https://img-blog.csdnimg.cn/img_convert/18a1fc6486b9a9db81c9d526532438a3.png" style="zoom: 50%;" />

- 读取binlog异步删除缓存

通过数据库的binlog来**异步淘汰key**

<img src="https://img-blog.csdnimg.cn/img_convert/dfbcd20d018b190bcf26b597ec81de9f.png" style="zoom: 50%;" />

- 可以使用阿里的**canal将binlog日志采集发送到MQ队列里面然后通过ACK机制确认处理这条更新消息，删除缓存**，保证数据缓存一致性

[](https://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&mid=2653557285&idx=1&sn=6eedd04eac05b1e531b8096ccd6e7cf9&chksm=813983bdb64e0aabf8bbcbb8e991b9045f7c675752debf966d53017ec4a0e495310dcc4cd4ac&mpshare=1&srcid=1016Yl8anhxtWuKI8SKLYEDr&sharer_sharetime=1634364868193&sharer_shareid=2bf0d8899ef3c7501d20b3a21b816303&from=singlemessage&scene=1&subscene=10000&clicktime=1634779662&enterid=1634779662&ascene=1&devicetype=android-30&version=28000f39&nettype=ctnet&abtest_cookie=AAACAA%3D%3D&lang=zh_CN&exportkey=AaOaGL1BPofOCZG%2F%2BV0VCBM%3D&pass_ticket=WXDx5OHa%2BYvJJHI4xgzF39p1DeTynkPBL8GPqqTd%2Brnn0A%2BhtLS9JGW8Hv7IowSZ&wx_header=1)



## <font color=red>14、缓存穿透</font>

客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。

![image-20240407190003945](Redis.assets/image-20240407190003945.png)

![image-20240407190635220](Redis.assets/image-20240407190635220.png)

## <font color=red>15、缓存雪崩</font>

![image-20240407191944439](Redis.assets/image-20240407191944439.png)

## <font color=red>16、缓存击穿</font>

![image-20240509095605280](Redis.assets/image-20240509095605280.png)

## 黑马点评逻辑

（缓存击穿）互斥锁/逻辑过期 ：下边两个在获取锁成功后，都需要再次查询缓存，若缓存中数据符合条件直接返回。

| ![image-20240510190321576](Redis.assets/image-20240510190321576.png) | ![image-20240510190517735](Redis.assets/image-20240510190517735.png) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

优惠券秒杀（全局唯一ID生成器---基于Redis）：

![image-20240512104853058](Redis.assets/image-20240512104853058.png)

redission可重入/可重试：

| <img src="Redis.assets/image-20240512085222453.png" alt="image-20240512085222453" style="zoom: 67%;" /> | <img src="Redis.assets/image-20240512105816975.png" alt="image-20240512105816975" style="zoom: 67%;" /> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |



| <img src="Redis.assets/image-20240512105239705.png" alt="image-20240512105239705" style="zoom: 67%;" /> | <img src="Redis.assets/image-20240512105522335.png" alt="image-20240512105522335" style="zoom: 67%;" /> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |



| ![image-20240513110518195](Redis.assets/image-20240513110518195.png) | ![image-20240513112918248](Redis.assets/image-20240513112918248.png) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

![image-20240513114043883](Redis.assets/image-20240513114043883.png)

小功能：

![image-20240514090917016](Redis.assets/image-20240514090917016.png)



缓存穿透---布隆

**布隆过滤器的基本原理：**

1.  **位数组（Bit Array）**：布隆过滤器使用一个包含大量二进制位的位数组，初始时所有位都被置为0。这个位数组通常会消耗一定数量的内存空间。
2.  **多个哈希函数（Hash Functions）**：布隆过滤器会预先定义若干个哈希函数，这些哈希函数可以将输入的元素映射到位数组中的不同位置。通常情况下，这些哈希函数会是独立且均匀分布的。
3.  **插入操作：当一个新的元素需要加入布隆过滤器时，该元素会经过多个哈希函数计算得到多个哈希值，然后将位数组中对应的位置设为1。** 
4.  **成员存在性检查**：当需要检查一个元素是否在布隆过滤器中时，同样会对这个元素进行多次哈希计算，然后检查对应位置上的值。如果所有的位置都为1，则认为该元素可能存在于集合中；如果存在任何一个位置为0，则可以肯定该元素不存在于集合中。

**需要注意的是，由于多个元素可能映射到位数组中的相同位置，因此布隆过滤器可能会出现“误伤”的情况，即某个元素被错误地判断为存在于集合中（false positive）。这种误判主要是由于哈希冲突引起的。**

**总的来说，布隆过滤器通过牺牲一定的准确性来换取内存占用和查询速度上的优势，因此在设计和使用时需要权衡误判率和内存消耗。**





 ![image-20240508202826128](Redis.assets/image-20240508202826128.png)

## 17、Redis的跳表是怎么实现的，性能如何，层高怎么生成的

<img src="C:\Users\耀\AppData\Roaming\Typora\typora-user-images\image-20240810200334142.png" alt="image-20240810200334142" style="zoom:50%;" />

[链接](https://huangz.works/redisbook1e/preview/skiplist/datastruct.html)

每次创建一个新跳跃表节点的时候， 程序都根据幂次定律 （[power law](http://en.wikipedia.org/wiki/Power_law)，越大的数出现的概率越小） 随机生成一个介于 `1` 和 `32` 之间的值作为 `level` 数组的大小， 这个大小就是层的“高度”；

~~~c
typedef struct zskiplistNode {
    // 后退指针
    struct zskiplistNode *backward;
    // 分值
    double score;
    // 成员对象
    robj *obj;
    // 层
    struct zskiplistLevel {
        // 前进指针
        struct zskiplistNode *forward;
        // 跨度
        unsigned int span;
    } level[];
} zskiplistNode;
typedef struct zskiplist {
    // 表头节点和表尾节点
    struct zskiplistNode *header, *tail;
    // 表中节点的数量
    unsigned long length;
    // 表中层数最大的节点的层数
    int level;
} zskiplist;
~~~











# 分布式

路由工厂：读取路由的判断规则，而后把他解析成对应的判断条件，等请求进来做判断。

<img src="Redis.assets/image-20240427205552841.png" alt="image-20240427205552841" style="zoom: 67%;" />

计算热点数据用到的方法：

<img src="Redis.assets/image-20240501095229051.png" alt="image-20240501095229051" style="zoom:50%;" />

![image-20240501095328905](Redis.assets/image-20240501095328905.png)

##1、什么是分布式？为什么需要分布式

分布式是指在多台计算机上协同⼯作的系统，这些计算机通过⽹络连接在⼀起，共同完成⼀个任务。 

分布式系统能够有效地解决单台计算机处理能⼒不⾜、系统容易宕机、数据存储容量有限等问题，同时能够提⾼系统的可靠性、可⽤性和性能，适⽤于数据量较⼤、并发量⾼、访问频繁的场景。  

在分布式系统中，由于数据和计算任务被分布在多台计算机上，不同计算机之间需要进⾏通信和协调，因此需要解决分布式⼀致性、负载均衡、故障恢复、数据共享和安全等问题，同时需要考虑数据的⼀致性和可靠性。因此，分布式系统的设计和实现⽐单机系统更加复杂和困难，需要考虑到多个因素的综合影响。





<img src="Redis.assets/image-20240514092604609.png" alt="image-20240514092604609" style="zoom:50%;" />

##2、什么是⽹关，⽹关有哪些作⽤？

⽹关（Gateway）是连接**两个或多个不同⽹络的设备**，可以实现**协议的转换、数据的转发和安全策略的实现**等功能。简单来说，⽹关是**设备与路由器之间的桥梁**，由它将不同的⽹络间进⾏访问的控制，转换，交接等等

常⻅的⽹关有**应⽤⽹关、协议⽹关、安全⽹关**等。

应⽤⽹关：⽤于应⽤层协议的处理，如 HTTP、SMTP 等。 

<img src="Redis.assets/image-20240427201934526.png" alt="image-20240427201934526" style="zoom: 67%;" />

<img src="Redis.assets/image-20240427201001789.png" alt="image-20240427201001789" style="zoom: 67%;" />

网关是基于webflux实现的。 

跨域问题：浏览器禁止请求的发起者与服务端发生跨域Ajax请求，请求被浏览器拦截的问题。

解决：CROS

## 3、Dubbo 是什么？是否了解过它的架构设计？

Apache Dubbo 是⼀款⾼性能的 **Java RPC** 框架。其前身是阿⾥巴巴公司开源的⼀个⾼性能、轻量级的开源 Java  RPC 框架，可以和 Spring 框架⽆缝集成。

**什么是RPC？**

RPC 全称为 remote procedure call，即远程过程调⽤。 ⽐如两台服务器 A 和 B，A 服务器上部署⼀个应⽤，B 服务器上部署⼀个应⽤，A 服务器上的应⽤想调⽤B 服务器 上的应⽤提供的⽅法，由于两个应⽤不在⼀个内存空间，不能直接调⽤，所以需要通过⽹络来表达调⽤的语义和传达调⽤的数据。

Dubbo 架构图：

![image-20240514094033367](Redis.assets/image-20240514094033367.png)

各节点⻆⾊说明：

![image-20240514094100061](Redis.assets/image-20240514094100061.png)

**调⽤关系说明：**

1. 服务容器负责启动，加载，运⾏服务提供者。 

2. 服务提供者在启动时，向注册中⼼注册⾃⼰提供的服务。 
3. 服务消费者在启动时，向注册中⼼订阅⾃⼰所需的服务。
4. 注册中⼼返回服务提供者地址列表给消费者，如果有变更，注册中⼼将基于⻓连接推送变更数据给消费者。 
5. 服务消费者，从提供者地址列表中，基于负载均衡算法，选⼀台提供者进⾏调⽤，如果调⽤失败，再选另⼀台调⽤。
6. 服务消费者和提供者，在内存中累计调⽤次数和调⽤时间，定时每分钟发送⼀次统计数据到监控中⼼。

##4、什么是分布式的 CAP 理论？

CAP 理论是指⼀个分布式系统中，不可能同时满⾜以下三个条件：

- **⼀致性（Consistency）**：所有节点在同⼀时间的看到的数据是⼀致的，即写**数据操作时要同时更新相关副本**，保证**强⼀致性** 
- **可⽤性（Availability）**：系统中能正常接收请求的节点都能在合理时间内返回结果，即**系统在某些节点失效下仍能对外提供服务**
- **分区容错性（Partition Tolerance）**：什么是分区？分布式系统中存在很多节点，这些节点之间通过⽹络进⾏通信，**当节点间的通信出了问题（如⽹络故障、机器故障等），就称系统出现了分区。⽽分区容错性就是出现 分区问题时，系统还能继续对外提供服务**

根据 CAP 理论，分布式系统只能满⾜其中的两个特性。然⽽实际上，**分区容错性是⼀定要满⾜的**，因为不可能只 要出现分区问题时整个系统就完全⽆法使⽤。因此，在分布式系统中，我们需要考虑的是当出现分区问题时，**选择的是⼀致性还是可⽤性，即 CP 还是 AP。**

- **CP 架构**：当系统出现分区故障时，客户端发送的任意请求都会被卡死或超时，保证数据的**强⼀致性**。如  **Zookeeper**

- **AP 架构**：当系统出现分区故障时，**客户端依旧能获取数据，但有的是新数据，有的是旧数据**。如 **Eureka**



## 5、什么是 RPC？⽬前有哪些常⻅的 RPC 框架？实现 RPC 框架的核⼼原理 是什么？

RPC【**Remote Procedure Call**】是指远程过程调⽤，是⼀种**进程间通信**⽅式，他是⼀种技术的思想，⽽不是规范。它**允许程序调⽤另⼀个地址空间（通常是共享⽹络的另⼀台机器上）的过程或函数**，⽽不⽤程序员显式编码这个远程调⽤的细节。即程序员⽆论是调⽤本地的还是远程的函数，**本质上编写的调⽤代码基本相同**。

<img src="Redis.assets/image-20240514095246125.png" alt="image-20240514095246125" style="zoom: 67%;" />

⽬前常⻅的 **RPC 框架**有：

1. Dubbo：阿⾥巴巴开源的分布式 RPC 框架，⽀持多种协议和负载均衡策略。 
2. gRPC：Google 开源的⾼性能 RPC 框架，⽀持多种语⾔。 
3. Thrift：Facebook 开源的跨语⾔ RPC 框架，⽀持多种传输协议和数据编解码⽅式。 
4. Spring Cloud Netflix：Spring Cloud 的⼦项⽬之⼀，提供了基于 Netflix OSS 开源组件的微服务解决⽅案， 包括服务发现、负载均衡、熔断器等功能。

## 6、什么是注册中心？如何实现⼀个注册中心？

注册中⼼是**服务实例信息的存储仓库，也是服务提供者和服务消费者进⾏交互的桥梁**。它主要提供了**服务注册和服务发现**这两⼤核⼼功能。在⼀个分布式系统中，不同的服务会以微服务的形式运⾏在不同的机器上，它们需要相互通信以完成业务逻辑。⽽注册中⼼则充当了服务之间的“⻩⻚”，记录了所有可⽤的服务及其⽹络地址，⽅便其他服 务进⾏查找和调⽤。 

当⼀个新的服务启动时，它会向注册中⼼注册⾃⼰的⽹络地址和⼀些元数据信息（例如服务名称、版本号、健康状态等），注册中⼼会将这些信息存储在⾃⼰的数据中⼼中。当其他服务需要调⽤这个新服务时，它们可以通过向注册中⼼查询来获取该服务的地址和元数据信息，然后与该服务建⽴⽹络连接。

 常⻅的注册中⼼包括 ZooKeeper、Consul、Eureka 、Nacos 等等

![image-20240427204241650](Redis.assets/image-20240427204241650.png)

实现⼀个注册中⼼：

1. 设计数据模型：设计注册中⼼的数据模型，包括服务的元数据信息、服务实例的⽹络地址等。

2. 实现服务注册：当服务启动时，它需要向注册中⼼注册⾃⼰的元数据信息和⽹络地址。可以通过 REST API、 RPC 等⽅式实现服务的注册。 
3. 实现服务发现：当⼀个服务需要调⽤其他服务时，它需要向注册中⼼查询⽬标服务的⽹络地址。可以通过  REST API、RPC 等⽅式实现服务的发现。 
4. 实现健康检查：为了保证服务的可⽤性，注册中⼼需要定期检查服务实例的健康状况，并将不健康的实例从服务列表中移除。 
5. 实现⾼可⽤：注册中⼼是⼀个分布式系统的核⼼组件，需要保证⾼可⽤性。可以采⽤主从复制、集群等⽅式实 现注册中⼼的⾼可⽤性。 
6. 实现安全机制：注册中⼼涉及到服务的元数据信息和⽹络地址等敏感信息，需要采取合适的安全措施

## 7、什么是分布式的 BASE 理论，它与 CAP 理论有什么联系？

BASE 理论是对 CAP 理论的延伸，核⼼思想是即使⽆法做到强⼀致性（Strong Consistency，CAP 的⼀致性就是强⼀致性），但应⽤可以采⽤适合的⽅式达到最终⼀致性（Eventual Consitency）。

1. Basically Available（基本可⽤）：分布式同再出现不可预知故障的时候，允许损失部分可⽤性

2. Soft state（软状态）：软状态也称弱状态，和硬状态相对，是指允许系统中的数据存在中间状态，并认为该 中间状态的存在不会影响系统的整体可⽤性，即允许系统在不同节点的数据副本之间进⾏数据同步的过程存在 延时 
3. Eventually consistent（最终⼀致性）：最终⼀致性强调的是系统中所有的数据副本，在经过⼀段时间上的同步后，最终能够达到⼀个⼀致的状态。因此，最终⼀致性的本质是需要系统保证最终数据能够达到⼀致，⽽不需要实时保证系统数据的强⼀致性

**CAP 与 BASE 关系**

BASE 是对 CAP 中⼀致性和可⽤性权衡的结果，其来源于对⼤规模互联⽹系统分布式实践的结论，是基于 CAP定理逐步演化⽽来的，其核⼼思想是即使⽆法做到强⼀致性（Strong consistency），更具体地说，是对 CAP 中 AP  ⽅案的⼀个补充。其基本思路就是：通过业务，牺牲强⼀致性⽽获得可⽤性，并允许数据在⼀段时间内是不⼀致 的，但是最终达到⼀致性状态。

![image-20240514095643706](Redis.assets/image-20240514095643706.png)





![image-20240521110925023](Redis.assets/image-20240521110925023.png)

![image-20240521110944896](Redis.assets/image-20240521110944896.png)

**事务协调器，起到一个拦截事务请求的作用。**

## 8、分布式事务解决方案

![image-20240521203221147](Redis.assets/image-20240521203221147.png)

## 9、幂等



![image-20240521212134725](Redis.assets/image-20240521212134725.png)

## 10、分布式任务调度

![image-20240521213330122](https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240521213330122.png)













# 消息队列

##1、什么是消息队列？消息队列有哪些应⽤场景？

消息队列是⼀种⽤于异步通信的机制，⽤于在不同的应⽤程序之间传递消息。消息队列通常由**消息⽣产者、消息队列和消息消费者**三部分组成。

消息⽣产者将消息发送到消息队列中，⽽消息消费者则从消息队列中接收消息。**消息队列负责存储和管理消息，确保消息传递的可靠性和稳定性。在实现过程中，消息队列还会提供⼀些额外的功能，如消息过滤、消息路由、消息持久化等**。

消息队列的特点：

1. **异步通信：**消息⽣产者和消息消费者之间采⽤异步通信模式，发送⽅⽆需等待接收⽅的响应即可继续执⾏。 

2. **解耦合：**消息队列可以将消息⽣产者和消息消费者解耦合，使得它们之间的关系更加灵活。 
3. **可靠性：**消息队列通常会提供⼀些保证消息传递可靠性的机制，如消息持久化、重试机制等。 4. 缓冲：消息队列可以缓冲来⾃多个消息⽣产者的消息，使得消息消费者可以按照⾃⼰的节奏进⾏消费，从⽽有 效地平衡⽣产者和消费者之间的处理速度。

消息队列的应⽤：

1. **异步任务处理：**通过将任务发送到消息队列中，异步处理任务，提⾼系统的并发性能和吞吐量。 

2. **解耦合系统：**将不同的业务逻辑拆分成不同的服务，通过消息队列实现服务之间的通信，提⾼系统的可维护性 和可扩展性。 
3. **流量削峰**：将流量通过消息队列分散到不同的服务中，避免单个服务被⾼并发流量打垮。 
4. **⽇志收集：**通过将⽇志消息发送到消息队列中，将⽇志收集和分析与业务逻辑解耦合，提⾼系统的可靠性和可 维护性

5. **应⽤解耦**：将不同的应⽤程序通过消息队列进⾏集成，实现应⽤之间的解耦合和数据交换。

##2、有哪些主流的消息队列，它们分别有什么优缺点、各⾃的适⽤场景是什 么？

![image-20240514100043079](https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240514100043079.png)



##3、有哪些常⻅的消息队列模型？分别适⽤于什么场景？

⼀、什么是消息队列

我们可以把消息队列⽐作是⼀个存放消息的容器，当我们需要使⽤消息的时候可以取出消息供⾃⼰使⽤。**消息队列是分布式系统中重要的组件，使⽤消息队列主要是为了通过异步处理提⾼系统性能和削峰、降低系统耦合性**

⼆、常⻅模型

**ActiveMQ，RabbitMQ，Kafka，RocketMQ**

1. 点对点模型（Point-to-Point Model）：也被称为队列模型，消息⽣产者将消息发送到队列中，然后消息消费 者从队列中获取消息并处理。适⽤于需要精确传递消息的场景，如订单处理、任务调度等。 

2. 发布/订阅模型（Publish/Subscribe Model）：也被称为主题模型，消息⽣产者将消息发送到主题中，然后主 题将消息⼴播给所有订阅该主题的消费者。适⽤于需要将消息⼴播给多个消费者的场景，如新闻订阅、实时数 据更新等。 
3. 管道模型（Pipes and Filters Model）：消息⽣产者将消息发送到管道中，然后管道中的过滤器依次处理消息 并将其发送给下⼀个过滤器。适⽤于需要将消息按照⼀定的处理流程进⾏处理的场景，如⽇志处理、数据清洗 等。

三、具体应⽤场景

1. **RabbitMQ：⾼吞吐量的消息队列；多种语⾔客户端库⽀持；⽀持多种消息协议；⽀持复杂的路由规则；⽀持 消息确认机制；适合任务队列、⽇志处理、消息通信等场景。** 
2. Apache Kafka：⾼吞吐量、⽀持百万级别的消息每秒处理能⼒；分布式、⾼可靠、可扩展；⽀持持久化存储 消息；数据复制⾄多个副本，保证数据可靠性；适合⼤规模数据流处理、⽇志系统等场景。 
3. Apache ActiveMQ：完全⽀持 JMS 规范，具有良好的跨语⾔⽀持；⽀持多种消息协议和多种持久化⽅式；具 有较强的安全机制和集群管理能⼒；适合企业级应⽤、⾦融⾏业等场景。 
4.  Apache RocketMQ：⾼吞吐量，低延迟，亿级消息堆积能⼒；⽀持事务消息、定时消息等⾼级特性；⽀持数 据双写，保证数据可靠性；适合⼤规模数据流处理、⾦融⽀付等⾼可靠性场景


##4、如何保证消息不丢失？

**RabbitMQ**

![image-20240521111731827](https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240521111731827.png)

![image-20240521112716302](Redis.assets/image-20240521112716302.png)

![](Redis.assets/image-20240521111858513.png)

消息、队列、交换机

![image-20240521112753397](Redis.assets/image-20240521112753397.png)

![image-20240521112345993](Redis.assets/image-20240521112345993.png)

kafka

![image-20240521170540203](Redis.assets/image-20240521170540203.png)

![image-20240521191838903](Redis.assets/image-20240521191838903.png)



## 5、消息的重复消费

![image-20240521113052775](Redis.assets/image-20240521113052775.png)



![image-20240521113104264](Redis.assets/image-20240521113104264.png)

## 6、RabbitMQ 死信交换机/延迟队列

![image-20240521113320746](Redis.assets/image-20240521113320746.png)

![image-20240521113956194](Redis.assets/image-20240521113956194.png)

![image-20240521114216907](Redis.assets/image-20240521114216907.png)

![image-20240521115026051](Redis.assets/image-20240521115026051.png)

## 7、消息堆积怎么解决？

![image-20240521145959612](https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240521145959612.png)

![image-20240521150319785](Redis.assets/image-20240521150319785.png)

RabbitMQ：惰性队列：

![image-20240521150127802](Redis.assets/image-20240521150127802.png)

RabbitMQ的高可用；普通集群、镜像集群、仲裁队列（用来代替镜像集群）

![image-20240521152128335](Redis.assets/image-20240521152128335.png)

![image-20240521164107445](Redis.assets/image-20240521164107445.png)



![image-20240521193413040](https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240521193413040.png)

##8、kafka数据清理机制

![image-20240521200429661](Redis.assets/image-20240521200429661.png)

## 9、kafka实现高性能的设计

零拷贝指的是cpu不参与拷贝，可以使用dma硬件参与拷贝而非cpu

![image-20240521201405088](Redis.assets/image-20240521201405088.png)

##10、



[https://github.com/shaogezhu/easy-rpc](https://gw-c.nowcoder.com/api/sparta/jump/link?link=https%3A%2F%2Fgithub.com%2Fshaogezhu%2Feasy-rpc)  

#JWT令牌技术?(及使用?)---cookie 和 session 企业开发已经基本不用了

[官网](https://jwt.io/)

**Cookie的缺点:**

**安全性问题**：Cookie可能会被截获或篡改，尤其是如果使用明文传输的话。虽然可以通过使用HTTPS和标记为安全的Cookie来提高安全性，但仍然存在潜在的风险。

**存储限制**：浏览器对每个域的Cookie数量和大小有限制。虽然现代浏览器支持更大的存储空间，但仍然存在限制。

**用户配置**：用户可能会禁用浏览器的Cookie功能，这会导致依赖于Cookie的应用程序无法正常工作。

**跨域问题**：默认情况下，Cookie遵循同源策略，只能在设置它们的域中使用，这限制了跨域请求的使用。

**Session的缺点:**

**服务器负担**：Session需要在服务器端存储用户状态，这会增加服务器的内存消耗，尤其是在高并发场景下。

**可扩展性**：在分布式系统中，Session的管理和同步会成为问题。需要额外的机制来保证不同服务器间的Session状态一致。

**性能开销**：每次请求都需要检查Session，这可能导致额外的数据库查询或其他存储机制的访问，影响性能。

**依赖Cookie**：虽然Session本身存储在服务器上，但Session ID通常是通过Cookie传递的，这意味着如果用户禁用了Cookie，Session机制也可能失效。



jwt令牌是如何解决原有cookie和session技术的缺点的？？

eg：JWT优点：	

1. 支持PC端、移动端  ？？
2. 解决集群环境下的认证问题？？ 
3. 减轻服务器的存储压力（无需在服务器端存储？？）

你不在服务器端存储，你怎么校验？难道用逻辑校验？

JWT 校验原理？？

JWT令牌是如何判断时间过的？？





#反向代理和正向代理的区别？为什么要反向代理？
正向代理：用来代理客户端，对服务器发起请求，服务器不知道哪个客户端发来的请求，只清楚是代理服务器发过来的，eg：我们常用的魔法；

反向代理：代理服务器将服务端的服务器隐藏起来，充当代理，客户端的请求会发送到代理服务器上。 

1. 负载均衡

反向代理最大的优点就是可以充当负载均衡器，高流量网站通常面临每分钟处理大量请求的问题，这可能会降低其系统性能并破坏响应时间。使用反向代理可以保证更好的用户体验和更快的响应。

1. 充当缓存

一些反向代理可以充当缓存机器。通常，如果您在一分钟内发送一千个请求请求相同的资源，这些请求将一遍遍地到达请求相同资源的服务器，浪费了资源和宝贵的时间。首次请求资源时，反向代理可以缓存(保存)获取的资源，等下次需要相同资源时，直接可以获取，节省了资源和时间。

1. 保障安全

如果使用反向代理，请求不会直接到达Web服务器。它们有助于保护Web服务器免受已知漏洞的影响。

# SpringCloud



![image-20240521090259863](https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240521090259863.png)

![image-20240521092554347](Redis.assets/image-20240521092554347.png)

![image-20240521095516111](Redis.assets/image-20240521095516111.png)

![image-20240521101912614](Redis.assets/image-20240521101912614.png)



| ![image-20240521103404530](Redis.assets/image-20240521103404530.png) | ![image-20240521103554430](https://raw.githubusercontent.com/watermelon-create/MyPic/img/img/image-20240521103554430.png) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

![image-20240521103625096](C:\Users\耀\Desktop\image-20240521103625096.png)

